// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "select_stmt.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace gunir {
namespace compiler {

namespace {

const ::google::protobuf::Descriptor* StringMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StringMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnPath_reflection_ = NULL;
const ::google::protobuf::Descriptor* ColumnPathList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ColumnPathList_reflection_ = NULL;
const ::google::protobuf::Descriptor* OrderColumnPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OrderColumnPath_reflection_ = NULL;
const ::google::protobuf::Descriptor* OrderColumnPathList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OrderColumnPathList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawAtomicExpression_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawAtomicExpression_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawExpression_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawExpression_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawExpressionList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawExpressionList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawArguments_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawArguments_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawFunction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawFunction_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* Limit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Limit_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawWithin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawWithin_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawTarget_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawTarget_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawTargetList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawTargetList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* RawTableList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RawTableList_reflection_ = NULL;
const ::google::protobuf::Descriptor* SelectStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SelectStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateTableStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateTableStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* DefineTableStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DefineTableStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* DropTableStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DropTableStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShowStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShowStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* HelpStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HelpStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* QuitStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QuitStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* HistoryStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HistoryStmt_reflection_ = NULL;
const ::google::protobuf::Descriptor* QueryStmt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QueryStmt_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* OrderType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Operators_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* JoinOperator_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_select_5fstmt_2eproto() {
  protobuf_AddDesc_select_5fstmt_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "select_stmt.proto");
  GOOGLE_CHECK(file != NULL);
  StringMessage_descriptor_ = file->message_type(0);
  static const int StringMessage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StringMessage, char_string_),
  };
  StringMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StringMessage_descriptor_,
      StringMessage::default_instance_,
      StringMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StringMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StringMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StringMessage));
  ColumnPath_descriptor_ = file->message_type(1);
  static const int ColumnPath_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPath, field_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPath, has_distinct_),
  };
  ColumnPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnPath_descriptor_,
      ColumnPath::default_instance_,
      ColumnPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnPath));
  ColumnPathList_descriptor_ = file->message_type(2);
  static const int ColumnPathList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPathList, path_list_),
  };
  ColumnPathList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ColumnPathList_descriptor_,
      ColumnPathList::default_instance_,
      ColumnPathList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPathList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ColumnPathList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ColumnPathList));
  OrderColumnPath_descriptor_ = file->message_type(3);
  static const int OrderColumnPath_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPath, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPath, type_),
  };
  OrderColumnPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OrderColumnPath_descriptor_,
      OrderColumnPath::default_instance_,
      OrderColumnPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OrderColumnPath));
  OrderColumnPathList_descriptor_ = file->message_type(4);
  static const int OrderColumnPathList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPathList, path_list_),
  };
  OrderColumnPathList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OrderColumnPathList_descriptor_,
      OrderColumnPathList::default_instance_,
      OrderColumnPathList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPathList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OrderColumnPathList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OrderColumnPathList));
  RawAtomicExpression_descriptor_ = file->message_type(5);
  static const int RawAtomicExpression_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, function_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, integer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, floating_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, boolean_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, char_string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, column_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, expression_),
  };
  RawAtomicExpression_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawAtomicExpression_descriptor_,
      RawAtomicExpression::default_instance_,
      RawAtomicExpression_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawAtomicExpression, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawAtomicExpression));
  RawExpression_descriptor_ = file->message_type(6);
  static const int RawExpression_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, atomic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, op_),
  };
  RawExpression_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawExpression_descriptor_,
      RawExpression::default_instance_,
      RawExpression_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpression, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawExpression));
  RawExpressionList_descriptor_ = file->message_type(7);
  static const int RawExpressionList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpressionList, expr_list_),
  };
  RawExpressionList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawExpressionList_descriptor_,
      RawExpressionList::default_instance_,
      RawExpressionList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpressionList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawExpressionList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawExpressionList));
  RawArguments_descriptor_ = file->message_type(8);
  static const int RawArguments_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawArguments, arg_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawArguments, arg_is_star_),
  };
  RawArguments_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawArguments_descriptor_,
      RawArguments::default_instance_,
      RawArguments_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawArguments, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawArguments, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawArguments));
  RawFunction_descriptor_ = file->message_type(9);
  static const int RawFunction_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawFunction, function_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawFunction, args_),
  };
  RawFunction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawFunction_descriptor_,
      RawFunction::default_instance_,
      RawFunction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawFunction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawFunction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawFunction));
  RawJoin_descriptor_ = file->message_type(10);
  static const int RawJoin_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawJoin, partner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawJoin, expression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawJoin, op_),
  };
  RawJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawJoin_descriptor_,
      RawJoin::default_instance_,
      RawJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawJoin));
  Limit_descriptor_ = file->message_type(11);
  static const int Limit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, number_),
  };
  Limit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Limit_descriptor_,
      Limit::default_instance_,
      Limit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Limit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Limit));
  RawWithin_descriptor_ = file->message_type(12);
  static const int RawWithin_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawWithin, is_record_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawWithin, column_),
  };
  RawWithin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawWithin_descriptor_,
      RawWithin::default_instance_,
      RawWithin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawWithin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawWithin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawWithin));
  RawTarget_descriptor_ = file->message_type(13);
  static const int RawTarget_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTarget, expression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTarget, within_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTarget, alias_),
  };
  RawTarget_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawTarget_descriptor_,
      RawTarget::default_instance_,
      RawTarget_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTarget, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTarget, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawTarget));
  RawTargetList_descriptor_ = file->message_type(14);
  static const int RawTargetList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTargetList, target_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTargetList, target_is_star_),
  };
  RawTargetList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawTargetList_descriptor_,
      RawTargetList::default_instance_,
      RawTargetList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTargetList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTargetList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawTargetList));
  RawTable_descriptor_ = file->message_type(15);
  static const int RawTable_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTable, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTable, select_stmt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTable, alias_),
  };
  RawTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawTable_descriptor_,
      RawTable::default_instance_,
      RawTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawTable));
  RawTableList_descriptor_ = file->message_type(16);
  static const int RawTableList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTableList, table_list_),
  };
  RawTableList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RawTableList_descriptor_,
      RawTableList::default_instance_,
      RawTableList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTableList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RawTableList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RawTableList));
  SelectStmt_descriptor_ = file->message_type(17);
  static const int SelectStmt_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, target_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, from_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, where_clause_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, join_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, groupby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, having_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, orderby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, limit_),
  };
  SelectStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SelectStmt_descriptor_,
      SelectStmt::default_instance_,
      SelectStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SelectStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SelectStmt));
  CreateTableStmt_descriptor_ = file->message_type(18);
  static const int CreateTableStmt_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, input_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, table_schema_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, message_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, charset_encoding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, table_type_),
  };
  CreateTableStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateTableStmt_descriptor_,
      CreateTableStmt::default_instance_,
      CreateTableStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateTableStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateTableStmt));
  DefineTableStmt_descriptor_ = file->message_type(19);
  static const int DefineTableStmt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DefineTableStmt, table_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DefineTableStmt, input_path_),
  };
  DefineTableStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DefineTableStmt_descriptor_,
      DefineTableStmt::default_instance_,
      DefineTableStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DefineTableStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DefineTableStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DefineTableStmt));
  DropTableStmt_descriptor_ = file->message_type(20);
  static const int DropTableStmt_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropTableStmt, table_name_),
  };
  DropTableStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DropTableStmt_descriptor_,
      DropTableStmt::default_instance_,
      DropTableStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropTableStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DropTableStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DropTableStmt));
  ShowStmt_descriptor_ = file->message_type(21);
  static const int ShowStmt_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowStmt, table_name_),
  };
  ShowStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShowStmt_descriptor_,
      ShowStmt::default_instance_,
      ShowStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShowStmt));
  HelpStmt_descriptor_ = file->message_type(22);
  static const int HelpStmt_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelpStmt, cmd_name_),
  };
  HelpStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HelpStmt_descriptor_,
      HelpStmt::default_instance_,
      HelpStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelpStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HelpStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HelpStmt));
  QuitStmt_descriptor_ = file->message_type(23);
  static const int QuitStmt_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QuitStmt, cmd_name_),
  };
  QuitStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QuitStmt_descriptor_,
      QuitStmt::default_instance_,
      QuitStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QuitStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QuitStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QuitStmt));
  HistoryStmt_descriptor_ = file->message_type(24);
  static const int HistoryStmt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HistoryStmt, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HistoryStmt, size_),
  };
  HistoryStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HistoryStmt_descriptor_,
      HistoryStmt::default_instance_,
      HistoryStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HistoryStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HistoryStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HistoryStmt));
  QueryStmt_descriptor_ = file->message_type(25);
  static const int QueryStmt_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, select_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, create_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, drop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, help_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, show_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, history_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, quit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, define_),
  };
  QueryStmt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QueryStmt_descriptor_,
      QueryStmt::default_instance_,
      QueryStmt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryStmt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QueryStmt));
  OrderType_descriptor_ = file->enum_type(0);
  Operators_descriptor_ = file->enum_type(1);
  JoinOperator_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_select_5fstmt_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StringMessage_descriptor_, &StringMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnPath_descriptor_, &ColumnPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ColumnPathList_descriptor_, &ColumnPathList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OrderColumnPath_descriptor_, &OrderColumnPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OrderColumnPathList_descriptor_, &OrderColumnPathList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawAtomicExpression_descriptor_, &RawAtomicExpression::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawExpression_descriptor_, &RawExpression::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawExpressionList_descriptor_, &RawExpressionList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawArguments_descriptor_, &RawArguments::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawFunction_descriptor_, &RawFunction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawJoin_descriptor_, &RawJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Limit_descriptor_, &Limit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawWithin_descriptor_, &RawWithin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawTarget_descriptor_, &RawTarget::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawTargetList_descriptor_, &RawTargetList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawTable_descriptor_, &RawTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RawTableList_descriptor_, &RawTableList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SelectStmt_descriptor_, &SelectStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateTableStmt_descriptor_, &CreateTableStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DefineTableStmt_descriptor_, &DefineTableStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DropTableStmt_descriptor_, &DropTableStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShowStmt_descriptor_, &ShowStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HelpStmt_descriptor_, &HelpStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QuitStmt_descriptor_, &QuitStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HistoryStmt_descriptor_, &HistoryStmt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QueryStmt_descriptor_, &QueryStmt::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_select_5fstmt_2eproto() {
  delete StringMessage::default_instance_;
  delete StringMessage_reflection_;
  delete ColumnPath::default_instance_;
  delete ColumnPath_reflection_;
  delete ColumnPathList::default_instance_;
  delete ColumnPathList_reflection_;
  delete OrderColumnPath::default_instance_;
  delete OrderColumnPath_reflection_;
  delete OrderColumnPathList::default_instance_;
  delete OrderColumnPathList_reflection_;
  delete RawAtomicExpression::default_instance_;
  delete RawAtomicExpression_reflection_;
  delete RawExpression::default_instance_;
  delete RawExpression_reflection_;
  delete RawExpressionList::default_instance_;
  delete RawExpressionList_reflection_;
  delete RawArguments::default_instance_;
  delete RawArguments_reflection_;
  delete RawFunction::default_instance_;
  delete RawFunction_reflection_;
  delete RawJoin::default_instance_;
  delete RawJoin_reflection_;
  delete Limit::default_instance_;
  delete Limit_reflection_;
  delete RawWithin::default_instance_;
  delete RawWithin_reflection_;
  delete RawTarget::default_instance_;
  delete RawTarget_reflection_;
  delete RawTargetList::default_instance_;
  delete RawTargetList_reflection_;
  delete RawTable::default_instance_;
  delete RawTable_reflection_;
  delete RawTableList::default_instance_;
  delete RawTableList_reflection_;
  delete SelectStmt::default_instance_;
  delete SelectStmt_reflection_;
  delete CreateTableStmt::default_instance_;
  delete CreateTableStmt_reflection_;
  delete DefineTableStmt::default_instance_;
  delete DefineTableStmt_reflection_;
  delete DropTableStmt::default_instance_;
  delete DropTableStmt_reflection_;
  delete ShowStmt::default_instance_;
  delete ShowStmt_reflection_;
  delete HelpStmt::default_instance_;
  delete HelpStmt_reflection_;
  delete QuitStmt::default_instance_;
  delete QuitStmt_reflection_;
  delete HistoryStmt::default_instance_;
  delete HistoryStmt_reflection_;
  delete QueryStmt::default_instance_;
  delete QueryStmt_reflection_;
}

void protobuf_AddDesc_select_5fstmt_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021select_stmt.proto\022\021gunir.compiler\"$"
    "\n\rStringMessage\022\023\n\013char_string\030\001 \002(\t\"X\n\n"
    "ColumnPath\0224\n\nfield_list\030\001 \003(\0132 .bigquer"
    "y.compiler.StringMessage\022\024\n\014has_distinct"
    "\030\002 \001(\010\"B\n\016ColumnPathList\0220\n\tpath_list\030\001 "
    "\003(\0132\035.gunir.compiler.ColumnPath\"j\n\017Or"
    "derColumnPath\022+\n\004path\030\001 \002(\0132\035.gunir.c"
    "ompiler.ColumnPath\022*\n\004type\030\002 \002(\0162\034.bigqu"
    "ery.compiler.OrderType\"L\n\023OrderColumnPat"
    "hList\0225\n\tpath_list\030\001 \003(\0132\".gunir.comp"
    "iler.OrderColumnPath\"\227\002\n\023RawAtomicExpres"
    "sion\0220\n\010function\030\001 \001(\0132\036.gunir.compil"
    "er.RawFunction\022\017\n\007integer\030\002 \001(\003\022\020\n\010float"
    "ing\030\003 \001(\001\022\017\n\007boolean\030\004 \001(\010\0225\n\013char_strin"
    "g\030\005 \001(\0132 .gunir.compiler.StringMessag"
    "e\022-\n\006column\030\006 \001(\0132\035.gunir.compiler.Co"
    "lumnPath\0224\n\nexpression\030\007 \001(\0132 .gunir."
    "compiler.RawExpression\"\322\001\n\rRawExpression"
    "\022.\n\004left\030\001 \001(\0132 .gunir.compiler.RawEx"
    "pression\022/\n\005right\030\002 \001(\0132 .gunir.compi"
    "ler.RawExpression\0226\n\006atomic\030\003 \001(\0132&.bigq"
    "uery.compiler.RawAtomicExpression\022(\n\002op\030"
    "\004 \001(\0162\034.gunir.compiler.Operators\"H\n\021R"
    "awExpressionList\0223\n\texpr_list\030\001 \003(\0132 .bi"
    "gquery.compiler.RawExpression\"[\n\014RawArgu"
    "ments\0226\n\010arg_list\030\001 \001(\0132$.gunir.compi"
    "ler.RawExpressionList\022\023\n\013arg_is_star\030\002 \002"
    "(\010\"u\n\013RawFunction\0227\n\rfunction_name\030\001 \002(\013"
    "2 .gunir.compiler.StringMessage\022-\n\004ar"
    "gs\030\002 \002(\0132\037.gunir.compiler.RawArgument"
    "s\"\232\001\n\007RawJoin\022,\n\007partner\030\001 \002(\0132\033.bigquer"
    "y.compiler.RawTable\0224\n\nexpression\030\002 \002(\0132"
    " .gunir.compiler.RawExpression\022+\n\002op\030"
    "\003 \002(\0162\037.gunir.compiler.JoinOperator\"&"
    "\n\005Limit\022\r\n\005start\030\001 \001(\005\022\016\n\006number\030\002 \002(\005\"M"
    "\n\tRawWithin\022\021\n\tis_record\030\001 \002(\010\022-\n\006column"
    "\030\002 \001(\0132\035.gunir.compiler.ColumnPath\"\240\001"
    "\n\tRawTarget\0224\n\nexpression\030\001 \002(\0132 .bigque"
    "ry.compiler.RawExpression\022,\n\006within\030\002 \001("
    "\0132\034.gunir.compiler.RawWithin\022/\n\005alias"
    "\030\003 \001(\0132 .gunir.compiler.StringMessage"
    "\"Z\n\rRawTargetList\0221\n\013target_list\030\001 \003(\0132\034"
    ".gunir.compiler.RawTarget\022\026\n\016target_i"
    "s_star\030\002 \002(\010\"\245\001\n\010RawTable\0224\n\ntable_name\030"
    "\001 \001(\0132 .gunir.compiler.StringMessage\022"
    "2\n\013select_stmt\030\002 \001(\0132\035.gunir.compiler"
    ".SelectStmt\022/\n\005alias\030\t \001(\0132 .gunir.co"
    "mpiler.StringMessage\"\?\n\014RawTableList\022/\n\n"
    "table_list\030\001 \003(\0132\033.gunir.compiler.Raw"
    "Table\"\241\003\n\nSelectStmt\0225\n\013target_list\030\001 \002("
    "\0132 .gunir.compiler.RawTargetList\0222\n\tf"
    "rom_list\030\002 \002(\0132\037.gunir.compiler.RawTa"
    "bleList\0226\n\014where_clause\030\003 \001(\0132 .gunir"
    ".compiler.RawExpression\022(\n\004join\030\004 \001(\0132\032."
    "gunir.compiler.RawJoin\0222\n\007groupby\030\005 \001"
    "(\0132!.gunir.compiler.ColumnPathList\0220\n"
    "\006having\030\006 \001(\0132 .gunir.compiler.RawExp"
    "ression\0227\n\007orderby\030\007 \001(\0132&.gunir.comp"
    "iler.OrderColumnPathList\022\'\n\005limit\030\010 \001(\0132"
    "\030.gunir.compiler.Limit\"\337\002\n\017CreateTabl"
    "eStmt\0224\n\ntable_name\030\001 \002(\0132 .gunir.com"
    "piler.StringMessage\0224\n\ninput_path\030\002 \002(\0132"
    " .gunir.compiler.StringMessage\0226\n\014tab"
    "le_schema\030\003 \002(\0132 .gunir.compiler.Stri"
    "ngMessage\0226\n\014message_name\030\004 \002(\0132 .bigque"
    "ry.compiler.StringMessage\022:\n\020charset_enc"
    "oding\030\005 \001(\0132 .gunir.compiler.StringMe"
    "ssage\0224\n\ntable_type\030\006 \001(\0132 .gunir.com"
    "piler.StringMessage\"}\n\017DefineTableStmt\0224"
    "\n\ntable_name\030\001 \002(\0132 .gunir.compiler.S"
    "tringMessage\0224\n\ninput_path\030\002 \002(\0132 .bigqu"
    "ery.compiler.StringMessage\"E\n\rDropTableS"
    "tmt\0224\n\ntable_name\030\001 \002(\0132 .gunir.compi"
    "ler.StringMessage\"@\n\010ShowStmt\0224\n\ntable_n"
    "ame\030\001 \001(\0132 .gunir.compiler.StringMess"
    "age\">\n\010HelpStmt\0222\n\010cmd_name\030\001 \001(\0132 .bigq"
    "uery.compiler.StringMessage\">\n\010QuitStmt\022"
    "2\n\010cmd_name\030\001 \001(\0132 .gunir.compiler.St"
    "ringMessage\"*\n\013HistoryStmt\022\r\n\005start\030\001 \001("
    "\005\022\014\n\004size\030\002 \001(\005\"\204\003\n\tQueryStmt\022-\n\006select\030"
    "\001 \001(\0132\035.gunir.compiler.SelectStmt\0222\n\006"
    "create\030\002 \001(\0132\".gunir.compiler.CreateT"
    "ableStmt\022.\n\004drop\030\003 \001(\0132 .gunir.compil"
    "er.DropTableStmt\022)\n\004help\030\004 \001(\0132\033.bigquer"
    "y.compiler.HelpStmt\022)\n\004show\030\005 \001(\0132\033.bigq"
    "uery.compiler.ShowStmt\022/\n\007history\030\006 \001(\0132"
    "\036.gunir.compiler.HistoryStmt\022)\n\004quit\030"
    "\007 \001(\0132\033.gunir.compiler.QuitStmt\0222\n\006de"
    "fine\030\010 \001(\0132\".gunir.compiler.DefineTab"
    "leStmt* \n\tOrderType\022\010\n\004kAsc\020\001\022\t\n\005kDesc\020\002"
    "*\315\002\n\tOperators\022\010\n\004kAdd\020\001\022\010\n\004kSub\020\002\022\010\n\004kM"
    "ul\020\003\022\010\n\004kDiv\020\004\022\016\n\nkRemainder\020\005\022\017\n\013kLogic"
    "alAnd\020\006\022\016\n\nkLogicalOr\020\007\022\017\n\013kLogicalNot\020\010"
    "\022\017\n\013kBitwiseAnd\020\t\022\016\n\nkBitwiseOr\020\n\022\017\n\013kBi"
    "twiseNot\020\013\022\017\n\013kBitwiseXor\020\014\022\025\n\021kBitwiseL"
    "eftShift\020\r\022\026\n\022kBitwiseRightShift\020\016\022\r\n\tkC"
    "ontains\020\017\022\021\n\rkGreaterEqual\020\020\022\014\n\010kGreater"
    "\020\021\022\016\n\nkLessEqual\020\022\022\t\n\005kLess\020\023\022\n\n\006kEqual\020"
    "\024\022\r\n\tkNotEqual\020\025**\n\014JoinOperator\022\n\n\006kInn"
    "er\020\001\022\016\n\nkLeftOuter\020\002", 3980);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "select_stmt.proto", &protobuf_RegisterTypes);
  StringMessage::default_instance_ = new StringMessage();
  ColumnPath::default_instance_ = new ColumnPath();
  ColumnPathList::default_instance_ = new ColumnPathList();
  OrderColumnPath::default_instance_ = new OrderColumnPath();
  OrderColumnPathList::default_instance_ = new OrderColumnPathList();
  RawAtomicExpression::default_instance_ = new RawAtomicExpression();
  RawExpression::default_instance_ = new RawExpression();
  RawExpressionList::default_instance_ = new RawExpressionList();
  RawArguments::default_instance_ = new RawArguments();
  RawFunction::default_instance_ = new RawFunction();
  RawJoin::default_instance_ = new RawJoin();
  Limit::default_instance_ = new Limit();
  RawWithin::default_instance_ = new RawWithin();
  RawTarget::default_instance_ = new RawTarget();
  RawTargetList::default_instance_ = new RawTargetList();
  RawTable::default_instance_ = new RawTable();
  RawTableList::default_instance_ = new RawTableList();
  SelectStmt::default_instance_ = new SelectStmt();
  CreateTableStmt::default_instance_ = new CreateTableStmt();
  DefineTableStmt::default_instance_ = new DefineTableStmt();
  DropTableStmt::default_instance_ = new DropTableStmt();
  ShowStmt::default_instance_ = new ShowStmt();
  HelpStmt::default_instance_ = new HelpStmt();
  QuitStmt::default_instance_ = new QuitStmt();
  HistoryStmt::default_instance_ = new HistoryStmt();
  QueryStmt::default_instance_ = new QueryStmt();
  StringMessage::default_instance_->InitAsDefaultInstance();
  ColumnPath::default_instance_->InitAsDefaultInstance();
  ColumnPathList::default_instance_->InitAsDefaultInstance();
  OrderColumnPath::default_instance_->InitAsDefaultInstance();
  OrderColumnPathList::default_instance_->InitAsDefaultInstance();
  RawAtomicExpression::default_instance_->InitAsDefaultInstance();
  RawExpression::default_instance_->InitAsDefaultInstance();
  RawExpressionList::default_instance_->InitAsDefaultInstance();
  RawArguments::default_instance_->InitAsDefaultInstance();
  RawFunction::default_instance_->InitAsDefaultInstance();
  RawJoin::default_instance_->InitAsDefaultInstance();
  Limit::default_instance_->InitAsDefaultInstance();
  RawWithin::default_instance_->InitAsDefaultInstance();
  RawTarget::default_instance_->InitAsDefaultInstance();
  RawTargetList::default_instance_->InitAsDefaultInstance();
  RawTable::default_instance_->InitAsDefaultInstance();
  RawTableList::default_instance_->InitAsDefaultInstance();
  SelectStmt::default_instance_->InitAsDefaultInstance();
  CreateTableStmt::default_instance_->InitAsDefaultInstance();
  DefineTableStmt::default_instance_->InitAsDefaultInstance();
  DropTableStmt::default_instance_->InitAsDefaultInstance();
  ShowStmt::default_instance_->InitAsDefaultInstance();
  HelpStmt::default_instance_->InitAsDefaultInstance();
  QuitStmt::default_instance_->InitAsDefaultInstance();
  HistoryStmt::default_instance_->InitAsDefaultInstance();
  QueryStmt::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_select_5fstmt_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_select_5fstmt_2eproto {
  StaticDescriptorInitializer_select_5fstmt_2eproto() {
    protobuf_AddDesc_select_5fstmt_2eproto();
  }
} static_descriptor_initializer_select_5fstmt_2eproto_;

const ::google::protobuf::EnumDescriptor* OrderType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderType_descriptor_;
}
bool OrderType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Operators_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Operators_descriptor_;
}
bool Operators_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* JoinOperator_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoinOperator_descriptor_;
}
bool JoinOperator_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int StringMessage::kCharStringFieldNumber;
#endif  // !_MSC_VER

StringMessage::StringMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StringMessage::InitAsDefaultInstance() {
}

StringMessage::StringMessage(const StringMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StringMessage::SharedCtor() {
  _cached_size_ = 0;
  char_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StringMessage::~StringMessage() {
  SharedDtor();
}

void StringMessage::SharedDtor() {
  if (char_string_ != &::google::protobuf::internal::kEmptyString) {
    delete char_string_;
  }
  if (this != default_instance_) {
  }
}

void StringMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StringMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StringMessage_descriptor_;
}

const StringMessage& StringMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

StringMessage* StringMessage::default_instance_ = NULL;

StringMessage* StringMessage::New() const {
  return new StringMessage;
}

void StringMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_char_string()) {
      if (char_string_ != &::google::protobuf::internal::kEmptyString) {
        char_string_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StringMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string char_string = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_char_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->char_string().data(), this->char_string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StringMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string char_string = 1;
  if (has_char_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->char_string().data(), this->char_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->char_string(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StringMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string char_string = 1;
  if (has_char_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->char_string().data(), this->char_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->char_string(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StringMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string char_string = 1;
    if (has_char_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->char_string());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StringMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StringMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StringMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StringMessage::MergeFrom(const StringMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_string()) {
      set_char_string(from.char_string());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StringMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StringMessage::CopyFrom(const StringMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void StringMessage::Swap(StringMessage* other) {
  if (other != this) {
    std::swap(char_string_, other->char_string_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StringMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StringMessage_descriptor_;
  metadata.reflection = StringMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnPath::kFieldListFieldNumber;
const int ColumnPath::kHasDistinctFieldNumber;
#endif  // !_MSC_VER

ColumnPath::ColumnPath()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnPath::InitAsDefaultInstance() {
}

ColumnPath::ColumnPath(const ColumnPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnPath::SharedCtor() {
  _cached_size_ = 0;
  has_distinct_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnPath::~ColumnPath() {
  SharedDtor();
}

void ColumnPath::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColumnPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnPath_descriptor_;
}

const ColumnPath& ColumnPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

ColumnPath* ColumnPath::default_instance_ = NULL;

ColumnPath* ColumnPath::New() const {
  return new ColumnPath;
}

void ColumnPath::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    has_distinct_ = false;
  }
  field_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.StringMessage field_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_field_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_field_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_field_list;
        if (input->ExpectTag(16)) goto parse_has_distinct;
        break;
      }
      
      // optional bool has_distinct = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_distinct:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_distinct_)));
          set_has_has_distinct();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.StringMessage field_list = 1;
  for (int i = 0; i < this->field_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->field_list(i), output);
  }
  
  // optional bool has_distinct = 2;
  if (has_has_distinct()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->has_distinct(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.StringMessage field_list = 1;
  for (int i = 0; i < this->field_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->field_list(i), target);
  }
  
  // optional bool has_distinct = 2;
  if (has_has_distinct()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->has_distinct(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnPath::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool has_distinct = 2;
    if (has_has_distinct()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .gunir.compiler.StringMessage field_list = 1;
  total_size += 1 * this->field_list_size();
  for (int i = 0; i < this->field_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnPath::MergeFrom(const ColumnPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  field_list_.MergeFrom(from.field_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_has_distinct()) {
      set_has_distinct(from.has_distinct());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnPath::CopyFrom(const ColumnPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnPath::IsInitialized() const {
  
  for (int i = 0; i < field_list_size(); i++) {
    if (!this->field_list(i).IsInitialized()) return false;
  }
  return true;
}

void ColumnPath::Swap(ColumnPath* other) {
  if (other != this) {
    field_list_.Swap(&other->field_list_);
    std::swap(has_distinct_, other->has_distinct_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnPath_descriptor_;
  metadata.reflection = ColumnPath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ColumnPathList::kPathListFieldNumber;
#endif  // !_MSC_VER

ColumnPathList::ColumnPathList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ColumnPathList::InitAsDefaultInstance() {
}

ColumnPathList::ColumnPathList(const ColumnPathList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ColumnPathList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ColumnPathList::~ColumnPathList() {
  SharedDtor();
}

void ColumnPathList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ColumnPathList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ColumnPathList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ColumnPathList_descriptor_;
}

const ColumnPathList& ColumnPathList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

ColumnPathList* ColumnPathList::default_instance_ = NULL;

ColumnPathList* ColumnPathList::New() const {
  return new ColumnPathList;
}

void ColumnPathList::Clear() {
  path_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ColumnPathList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.ColumnPath path_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_path_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_path_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ColumnPathList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.ColumnPath path_list = 1;
  for (int i = 0; i < this->path_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->path_list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ColumnPathList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.ColumnPath path_list = 1;
  for (int i = 0; i < this->path_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->path_list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ColumnPathList::ByteSize() const {
  int total_size = 0;
  
  // repeated .gunir.compiler.ColumnPath path_list = 1;
  total_size += 1 * this->path_list_size();
  for (int i = 0; i < this->path_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ColumnPathList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ColumnPathList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ColumnPathList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ColumnPathList::MergeFrom(const ColumnPathList& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_list_.MergeFrom(from.path_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ColumnPathList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ColumnPathList::CopyFrom(const ColumnPathList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnPathList::IsInitialized() const {
  
  for (int i = 0; i < path_list_size(); i++) {
    if (!this->path_list(i).IsInitialized()) return false;
  }
  return true;
}

void ColumnPathList::Swap(ColumnPathList* other) {
  if (other != this) {
    path_list_.Swap(&other->path_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ColumnPathList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ColumnPathList_descriptor_;
  metadata.reflection = ColumnPathList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OrderColumnPath::kPathFieldNumber;
const int OrderColumnPath::kTypeFieldNumber;
#endif  // !_MSC_VER

OrderColumnPath::OrderColumnPath()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OrderColumnPath::InitAsDefaultInstance() {
  path_ = const_cast< ::gunir::compiler::ColumnPath*>(&::gunir::compiler::ColumnPath::default_instance());
}

OrderColumnPath::OrderColumnPath(const OrderColumnPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OrderColumnPath::SharedCtor() {
  _cached_size_ = 0;
  path_ = NULL;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OrderColumnPath::~OrderColumnPath() {
  SharedDtor();
}

void OrderColumnPath::SharedDtor() {
  if (this != default_instance_) {
    delete path_;
  }
}

void OrderColumnPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OrderColumnPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderColumnPath_descriptor_;
}

const OrderColumnPath& OrderColumnPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

OrderColumnPath* OrderColumnPath::default_instance_ = NULL;

OrderColumnPath* OrderColumnPath::New() const {
  return new OrderColumnPath;
}

void OrderColumnPath::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_path()) {
      if (path_ != NULL) path_->::gunir::compiler::ColumnPath::Clear();
    }
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OrderColumnPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.ColumnPath path = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // required .gunir.compiler.OrderType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (gunir::compiler::OrderType_IsValid(value)) {
            set_type(static_cast< gunir::compiler::OrderType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OrderColumnPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.ColumnPath path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->path(), output);
  }
  
  // required .gunir.compiler.OrderType type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OrderColumnPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.ColumnPath path = 1;
  if (has_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->path(), target);
  }
  
  // required .gunir.compiler.OrderType type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OrderColumnPath::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.ColumnPath path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->path());
    }
    
    // required .gunir.compiler.OrderType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OrderColumnPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OrderColumnPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OrderColumnPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OrderColumnPath::MergeFrom(const OrderColumnPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      mutable_path()->::gunir::compiler::ColumnPath::MergeFrom(from.path());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OrderColumnPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OrderColumnPath::CopyFrom(const OrderColumnPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderColumnPath::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_path()) {
    if (!this->path().IsInitialized()) return false;
  }
  return true;
}

void OrderColumnPath::Swap(OrderColumnPath* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OrderColumnPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OrderColumnPath_descriptor_;
  metadata.reflection = OrderColumnPath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OrderColumnPathList::kPathListFieldNumber;
#endif  // !_MSC_VER

OrderColumnPathList::OrderColumnPathList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OrderColumnPathList::InitAsDefaultInstance() {
}

OrderColumnPathList::OrderColumnPathList(const OrderColumnPathList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OrderColumnPathList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OrderColumnPathList::~OrderColumnPathList() {
  SharedDtor();
}

void OrderColumnPathList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OrderColumnPathList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OrderColumnPathList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OrderColumnPathList_descriptor_;
}

const OrderColumnPathList& OrderColumnPathList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

OrderColumnPathList* OrderColumnPathList::default_instance_ = NULL;

OrderColumnPathList* OrderColumnPathList::New() const {
  return new OrderColumnPathList;
}

void OrderColumnPathList::Clear() {
  path_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OrderColumnPathList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.OrderColumnPath path_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_path_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_path_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OrderColumnPathList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.OrderColumnPath path_list = 1;
  for (int i = 0; i < this->path_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->path_list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OrderColumnPathList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.OrderColumnPath path_list = 1;
  for (int i = 0; i < this->path_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->path_list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OrderColumnPathList::ByteSize() const {
  int total_size = 0;
  
  // repeated .gunir.compiler.OrderColumnPath path_list = 1;
  total_size += 1 * this->path_list_size();
  for (int i = 0; i < this->path_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OrderColumnPathList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OrderColumnPathList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OrderColumnPathList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OrderColumnPathList::MergeFrom(const OrderColumnPathList& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_list_.MergeFrom(from.path_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OrderColumnPathList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OrderColumnPathList::CopyFrom(const OrderColumnPathList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OrderColumnPathList::IsInitialized() const {
  
  for (int i = 0; i < path_list_size(); i++) {
    if (!this->path_list(i).IsInitialized()) return false;
  }
  return true;
}

void OrderColumnPathList::Swap(OrderColumnPathList* other) {
  if (other != this) {
    path_list_.Swap(&other->path_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OrderColumnPathList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OrderColumnPathList_descriptor_;
  metadata.reflection = OrderColumnPathList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawAtomicExpression::kFunctionFieldNumber;
const int RawAtomicExpression::kIntegerFieldNumber;
const int RawAtomicExpression::kFloatingFieldNumber;
const int RawAtomicExpression::kBooleanFieldNumber;
const int RawAtomicExpression::kCharStringFieldNumber;
const int RawAtomicExpression::kColumnFieldNumber;
const int RawAtomicExpression::kExpressionFieldNumber;
#endif  // !_MSC_VER

RawAtomicExpression::RawAtomicExpression()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawAtomicExpression::InitAsDefaultInstance() {
  function_ = const_cast< ::gunir::compiler::RawFunction*>(&::gunir::compiler::RawFunction::default_instance());
  char_string_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  column_ = const_cast< ::gunir::compiler::ColumnPath*>(&::gunir::compiler::ColumnPath::default_instance());
  expression_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
}

RawAtomicExpression::RawAtomicExpression(const RawAtomicExpression& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawAtomicExpression::SharedCtor() {
  _cached_size_ = 0;
  function_ = NULL;
  integer_ = GOOGLE_LONGLONG(0);
  floating_ = 0;
  boolean_ = false;
  char_string_ = NULL;
  column_ = NULL;
  expression_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawAtomicExpression::~RawAtomicExpression() {
  SharedDtor();
}

void RawAtomicExpression::SharedDtor() {
  if (this != default_instance_) {
    delete function_;
    delete char_string_;
    delete column_;
    delete expression_;
  }
}

void RawAtomicExpression::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawAtomicExpression::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawAtomicExpression_descriptor_;
}

const RawAtomicExpression& RawAtomicExpression::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawAtomicExpression* RawAtomicExpression::default_instance_ = NULL;

RawAtomicExpression* RawAtomicExpression::New() const {
  return new RawAtomicExpression;
}

void RawAtomicExpression::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_function()) {
      if (function_ != NULL) function_->::gunir::compiler::RawFunction::Clear();
    }
    integer_ = GOOGLE_LONGLONG(0);
    floating_ = 0;
    boolean_ = false;
    if (has_char_string()) {
      if (char_string_ != NULL) char_string_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_column()) {
      if (column_ != NULL) column_->::gunir::compiler::ColumnPath::Clear();
    }
    if (has_expression()) {
      if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawAtomicExpression::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.RawFunction function = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_function()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_integer;
        break;
      }
      
      // optional int64 integer = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_integer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &integer_)));
          set_has_integer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_floating;
        break;
      }
      
      // optional double floating = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_floating:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &floating_)));
          set_has_floating();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_boolean;
        break;
      }
      
      // optional bool boolean = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boolean:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &boolean_)));
          set_has_boolean();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_char_string;
        break;
      }
      
      // optional .gunir.compiler.StringMessage char_string = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_char_string()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_column;
        break;
      }
      
      // optional .gunir.compiler.ColumnPath column = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_column()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_expression;
        break;
      }
      
      // optional .gunir.compiler.RawExpression expression = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_expression:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expression()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawAtomicExpression::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.RawFunction function = 1;
  if (has_function()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->function(), output);
  }
  
  // optional int64 integer = 2;
  if (has_integer()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->integer(), output);
  }
  
  // optional double floating = 3;
  if (has_floating()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->floating(), output);
  }
  
  // optional bool boolean = 4;
  if (has_boolean()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->boolean(), output);
  }
  
  // optional .gunir.compiler.StringMessage char_string = 5;
  if (has_char_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->char_string(), output);
  }
  
  // optional .gunir.compiler.ColumnPath column = 6;
  if (has_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->column(), output);
  }
  
  // optional .gunir.compiler.RawExpression expression = 7;
  if (has_expression()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->expression(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawAtomicExpression::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.RawFunction function = 1;
  if (has_function()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->function(), target);
  }
  
  // optional int64 integer = 2;
  if (has_integer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->integer(), target);
  }
  
  // optional double floating = 3;
  if (has_floating()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->floating(), target);
  }
  
  // optional bool boolean = 4;
  if (has_boolean()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->boolean(), target);
  }
  
  // optional .gunir.compiler.StringMessage char_string = 5;
  if (has_char_string()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->char_string(), target);
  }
  
  // optional .gunir.compiler.ColumnPath column = 6;
  if (has_column()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->column(), target);
  }
  
  // optional .gunir.compiler.RawExpression expression = 7;
  if (has_expression()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->expression(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawAtomicExpression::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.RawFunction function = 1;
    if (has_function()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->function());
    }
    
    // optional int64 integer = 2;
    if (has_integer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->integer());
    }
    
    // optional double floating = 3;
    if (has_floating()) {
      total_size += 1 + 8;
    }
    
    // optional bool boolean = 4;
    if (has_boolean()) {
      total_size += 1 + 1;
    }
    
    // optional .gunir.compiler.StringMessage char_string = 5;
    if (has_char_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->char_string());
    }
    
    // optional .gunir.compiler.ColumnPath column = 6;
    if (has_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->column());
    }
    
    // optional .gunir.compiler.RawExpression expression = 7;
    if (has_expression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expression());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawAtomicExpression::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawAtomicExpression* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawAtomicExpression*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawAtomicExpression::MergeFrom(const RawAtomicExpression& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function()) {
      mutable_function()->::gunir::compiler::RawFunction::MergeFrom(from.function());
    }
    if (from.has_integer()) {
      set_integer(from.integer());
    }
    if (from.has_floating()) {
      set_floating(from.floating());
    }
    if (from.has_boolean()) {
      set_boolean(from.boolean());
    }
    if (from.has_char_string()) {
      mutable_char_string()->::gunir::compiler::StringMessage::MergeFrom(from.char_string());
    }
    if (from.has_column()) {
      mutable_column()->::gunir::compiler::ColumnPath::MergeFrom(from.column());
    }
    if (from.has_expression()) {
      mutable_expression()->::gunir::compiler::RawExpression::MergeFrom(from.expression());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawAtomicExpression::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawAtomicExpression::CopyFrom(const RawAtomicExpression& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawAtomicExpression::IsInitialized() const {
  
  if (has_function()) {
    if (!this->function().IsInitialized()) return false;
  }
  if (has_char_string()) {
    if (!this->char_string().IsInitialized()) return false;
  }
  if (has_column()) {
    if (!this->column().IsInitialized()) return false;
  }
  if (has_expression()) {
    if (!this->expression().IsInitialized()) return false;
  }
  return true;
}

void RawAtomicExpression::Swap(RawAtomicExpression* other) {
  if (other != this) {
    std::swap(function_, other->function_);
    std::swap(integer_, other->integer_);
    std::swap(floating_, other->floating_);
    std::swap(boolean_, other->boolean_);
    std::swap(char_string_, other->char_string_);
    std::swap(column_, other->column_);
    std::swap(expression_, other->expression_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawAtomicExpression::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawAtomicExpression_descriptor_;
  metadata.reflection = RawAtomicExpression_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawExpression::kLeftFieldNumber;
const int RawExpression::kRightFieldNumber;
const int RawExpression::kAtomicFieldNumber;
const int RawExpression::kOpFieldNumber;
#endif  // !_MSC_VER

RawExpression::RawExpression()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawExpression::InitAsDefaultInstance() {
  left_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
  right_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
  atomic_ = const_cast< ::gunir::compiler::RawAtomicExpression*>(&::gunir::compiler::RawAtomicExpression::default_instance());
}

RawExpression::RawExpression(const RawExpression& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawExpression::SharedCtor() {
  _cached_size_ = 0;
  left_ = NULL;
  right_ = NULL;
  atomic_ = NULL;
  op_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawExpression::~RawExpression() {
  SharedDtor();
}

void RawExpression::SharedDtor() {
  if (this != default_instance_) {
    delete left_;
    delete right_;
    delete atomic_;
  }
}

void RawExpression::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawExpression::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawExpression_descriptor_;
}

const RawExpression& RawExpression::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawExpression* RawExpression::default_instance_ = NULL;

RawExpression* RawExpression::New() const {
  return new RawExpression;
}

void RawExpression::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_left()) {
      if (left_ != NULL) left_->::gunir::compiler::RawExpression::Clear();
    }
    if (has_right()) {
      if (right_ != NULL) right_->::gunir::compiler::RawExpression::Clear();
    }
    if (has_atomic()) {
      if (atomic_ != NULL) atomic_->::gunir::compiler::RawAtomicExpression::Clear();
    }
    op_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawExpression::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.RawExpression left = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_left()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_right;
        break;
      }
      
      // optional .gunir.compiler.RawExpression right = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_right()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_atomic;
        break;
      }
      
      // optional .gunir.compiler.RawAtomicExpression atomic = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_atomic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_atomic()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_op;
        break;
      }
      
      // optional .gunir.compiler.Operators op = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_op:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (gunir::compiler::Operators_IsValid(value)) {
            set_op(static_cast< gunir::compiler::Operators >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawExpression::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.RawExpression left = 1;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->left(), output);
  }
  
  // optional .gunir.compiler.RawExpression right = 2;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->right(), output);
  }
  
  // optional .gunir.compiler.RawAtomicExpression atomic = 3;
  if (has_atomic()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->atomic(), output);
  }
  
  // optional .gunir.compiler.Operators op = 4;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->op(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawExpression::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.RawExpression left = 1;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->left(), target);
  }
  
  // optional .gunir.compiler.RawExpression right = 2;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->right(), target);
  }
  
  // optional .gunir.compiler.RawAtomicExpression atomic = 3;
  if (has_atomic()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->atomic(), target);
  }
  
  // optional .gunir.compiler.Operators op = 4;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->op(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawExpression::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.RawExpression left = 1;
    if (has_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->left());
    }
    
    // optional .gunir.compiler.RawExpression right = 2;
    if (has_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->right());
    }
    
    // optional .gunir.compiler.RawAtomicExpression atomic = 3;
    if (has_atomic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->atomic());
    }
    
    // optional .gunir.compiler.Operators op = 4;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->op());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawExpression::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawExpression* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawExpression*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawExpression::MergeFrom(const RawExpression& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_left()) {
      mutable_left()->::gunir::compiler::RawExpression::MergeFrom(from.left());
    }
    if (from.has_right()) {
      mutable_right()->::gunir::compiler::RawExpression::MergeFrom(from.right());
    }
    if (from.has_atomic()) {
      mutable_atomic()->::gunir::compiler::RawAtomicExpression::MergeFrom(from.atomic());
    }
    if (from.has_op()) {
      set_op(from.op());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawExpression::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawExpression::CopyFrom(const RawExpression& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawExpression::IsInitialized() const {
  
  if (has_left()) {
    if (!this->left().IsInitialized()) return false;
  }
  if (has_right()) {
    if (!this->right().IsInitialized()) return false;
  }
  if (has_atomic()) {
    if (!this->atomic().IsInitialized()) return false;
  }
  return true;
}

void RawExpression::Swap(RawExpression* other) {
  if (other != this) {
    std::swap(left_, other->left_);
    std::swap(right_, other->right_);
    std::swap(atomic_, other->atomic_);
    std::swap(op_, other->op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawExpression::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawExpression_descriptor_;
  metadata.reflection = RawExpression_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawExpressionList::kExprListFieldNumber;
#endif  // !_MSC_VER

RawExpressionList::RawExpressionList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawExpressionList::InitAsDefaultInstance() {
}

RawExpressionList::RawExpressionList(const RawExpressionList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawExpressionList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawExpressionList::~RawExpressionList() {
  SharedDtor();
}

void RawExpressionList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RawExpressionList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawExpressionList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawExpressionList_descriptor_;
}

const RawExpressionList& RawExpressionList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawExpressionList* RawExpressionList::default_instance_ = NULL;

RawExpressionList* RawExpressionList::New() const {
  return new RawExpressionList;
}

void RawExpressionList::Clear() {
  expr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawExpressionList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.RawExpression expr_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_expr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_expr_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_expr_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawExpressionList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.RawExpression expr_list = 1;
  for (int i = 0; i < this->expr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expr_list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawExpressionList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.RawExpression expr_list = 1;
  for (int i = 0; i < this->expr_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expr_list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawExpressionList::ByteSize() const {
  int total_size = 0;
  
  // repeated .gunir.compiler.RawExpression expr_list = 1;
  total_size += 1 * this->expr_list_size();
  for (int i = 0; i < this->expr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->expr_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawExpressionList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawExpressionList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawExpressionList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawExpressionList::MergeFrom(const RawExpressionList& from) {
  GOOGLE_CHECK_NE(&from, this);
  expr_list_.MergeFrom(from.expr_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawExpressionList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawExpressionList::CopyFrom(const RawExpressionList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawExpressionList::IsInitialized() const {
  
  for (int i = 0; i < expr_list_size(); i++) {
    if (!this->expr_list(i).IsInitialized()) return false;
  }
  return true;
}

void RawExpressionList::Swap(RawExpressionList* other) {
  if (other != this) {
    expr_list_.Swap(&other->expr_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawExpressionList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawExpressionList_descriptor_;
  metadata.reflection = RawExpressionList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawArguments::kArgListFieldNumber;
const int RawArguments::kArgIsStarFieldNumber;
#endif  // !_MSC_VER

RawArguments::RawArguments()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawArguments::InitAsDefaultInstance() {
  arg_list_ = const_cast< ::gunir::compiler::RawExpressionList*>(&::gunir::compiler::RawExpressionList::default_instance());
}

RawArguments::RawArguments(const RawArguments& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawArguments::SharedCtor() {
  _cached_size_ = 0;
  arg_list_ = NULL;
  arg_is_star_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawArguments::~RawArguments() {
  SharedDtor();
}

void RawArguments::SharedDtor() {
  if (this != default_instance_) {
    delete arg_list_;
  }
}

void RawArguments::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawArguments::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawArguments_descriptor_;
}

const RawArguments& RawArguments::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawArguments* RawArguments::default_instance_ = NULL;

RawArguments* RawArguments::New() const {
  return new RawArguments;
}

void RawArguments::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_arg_list()) {
      if (arg_list_ != NULL) arg_list_->::gunir::compiler::RawExpressionList::Clear();
    }
    arg_is_star_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawArguments::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.RawExpressionList arg_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_arg_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_arg_is_star;
        break;
      }
      
      // required bool arg_is_star = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_arg_is_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &arg_is_star_)));
          set_has_arg_is_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawArguments::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.RawExpressionList arg_list = 1;
  if (has_arg_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->arg_list(), output);
  }
  
  // required bool arg_is_star = 2;
  if (has_arg_is_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->arg_is_star(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawArguments::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.RawExpressionList arg_list = 1;
  if (has_arg_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->arg_list(), target);
  }
  
  // required bool arg_is_star = 2;
  if (has_arg_is_star()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->arg_is_star(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawArguments::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.RawExpressionList arg_list = 1;
    if (has_arg_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->arg_list());
    }
    
    // required bool arg_is_star = 2;
    if (has_arg_is_star()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawArguments::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawArguments* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawArguments*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawArguments::MergeFrom(const RawArguments& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_arg_list()) {
      mutable_arg_list()->::gunir::compiler::RawExpressionList::MergeFrom(from.arg_list());
    }
    if (from.has_arg_is_star()) {
      set_arg_is_star(from.arg_is_star());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawArguments::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawArguments::CopyFrom(const RawArguments& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawArguments::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  if (has_arg_list()) {
    if (!this->arg_list().IsInitialized()) return false;
  }
  return true;
}

void RawArguments::Swap(RawArguments* other) {
  if (other != this) {
    std::swap(arg_list_, other->arg_list_);
    std::swap(arg_is_star_, other->arg_is_star_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawArguments::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawArguments_descriptor_;
  metadata.reflection = RawArguments_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawFunction::kFunctionNameFieldNumber;
const int RawFunction::kArgsFieldNumber;
#endif  // !_MSC_VER

RawFunction::RawFunction()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawFunction::InitAsDefaultInstance() {
  function_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  args_ = const_cast< ::gunir::compiler::RawArguments*>(&::gunir::compiler::RawArguments::default_instance());
}

RawFunction::RawFunction(const RawFunction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawFunction::SharedCtor() {
  _cached_size_ = 0;
  function_name_ = NULL;
  args_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawFunction::~RawFunction() {
  SharedDtor();
}

void RawFunction::SharedDtor() {
  if (this != default_instance_) {
    delete function_name_;
    delete args_;
  }
}

void RawFunction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawFunction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawFunction_descriptor_;
}

const RawFunction& RawFunction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawFunction* RawFunction::default_instance_ = NULL;

RawFunction* RawFunction::New() const {
  return new RawFunction;
}

void RawFunction::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_function_name()) {
      if (function_name_ != NULL) function_name_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_args()) {
      if (args_ != NULL) args_->::gunir::compiler::RawArguments::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawFunction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.StringMessage function_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_function_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_args;
        break;
      }
      
      // required .gunir.compiler.RawArguments args = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawFunction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.StringMessage function_name = 1;
  if (has_function_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->function_name(), output);
  }
  
  // required .gunir.compiler.RawArguments args = 2;
  if (has_args()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->args(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawFunction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.StringMessage function_name = 1;
  if (has_function_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->function_name(), target);
  }
  
  // required .gunir.compiler.RawArguments args = 2;
  if (has_args()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->args(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawFunction::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.StringMessage function_name = 1;
    if (has_function_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->function_name());
    }
    
    // required .gunir.compiler.RawArguments args = 2;
    if (has_args()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->args());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawFunction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawFunction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawFunction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawFunction::MergeFrom(const RawFunction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function_name()) {
      mutable_function_name()->::gunir::compiler::StringMessage::MergeFrom(from.function_name());
    }
    if (from.has_args()) {
      mutable_args()->::gunir::compiler::RawArguments::MergeFrom(from.args());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawFunction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawFunction::CopyFrom(const RawFunction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawFunction::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_function_name()) {
    if (!this->function_name().IsInitialized()) return false;
  }
  if (has_args()) {
    if (!this->args().IsInitialized()) return false;
  }
  return true;
}

void RawFunction::Swap(RawFunction* other) {
  if (other != this) {
    std::swap(function_name_, other->function_name_);
    std::swap(args_, other->args_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawFunction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawFunction_descriptor_;
  metadata.reflection = RawFunction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawJoin::kPartnerFieldNumber;
const int RawJoin::kExpressionFieldNumber;
const int RawJoin::kOpFieldNumber;
#endif  // !_MSC_VER

RawJoin::RawJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawJoin::InitAsDefaultInstance() {
  partner_ = const_cast< ::gunir::compiler::RawTable*>(&::gunir::compiler::RawTable::default_instance());
  expression_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
}

RawJoin::RawJoin(const RawJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawJoin::SharedCtor() {
  _cached_size_ = 0;
  partner_ = NULL;
  expression_ = NULL;
  op_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawJoin::~RawJoin() {
  SharedDtor();
}

void RawJoin::SharedDtor() {
  if (this != default_instance_) {
    delete partner_;
    delete expression_;
  }
}

void RawJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawJoin_descriptor_;
}

const RawJoin& RawJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawJoin* RawJoin::default_instance_ = NULL;

RawJoin* RawJoin::New() const {
  return new RawJoin;
}

void RawJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_partner()) {
      if (partner_ != NULL) partner_->::gunir::compiler::RawTable::Clear();
    }
    if (has_expression()) {
      if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
    }
    op_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.RawTable partner = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_partner()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_expression;
        break;
      }
      
      // required .gunir.compiler.RawExpression expression = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_expression:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expression()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_op;
        break;
      }
      
      // required .gunir.compiler.JoinOperator op = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_op:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (gunir::compiler::JoinOperator_IsValid(value)) {
            set_op(static_cast< gunir::compiler::JoinOperator >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.RawTable partner = 1;
  if (has_partner()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->partner(), output);
  }
  
  // required .gunir.compiler.RawExpression expression = 2;
  if (has_expression()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->expression(), output);
  }
  
  // required .gunir.compiler.JoinOperator op = 3;
  if (has_op()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->op(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.RawTable partner = 1;
  if (has_partner()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->partner(), target);
  }
  
  // required .gunir.compiler.RawExpression expression = 2;
  if (has_expression()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->expression(), target);
  }
  
  // required .gunir.compiler.JoinOperator op = 3;
  if (has_op()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->op(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawJoin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.RawTable partner = 1;
    if (has_partner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->partner());
    }
    
    // required .gunir.compiler.RawExpression expression = 2;
    if (has_expression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expression());
    }
    
    // required .gunir.compiler.JoinOperator op = 3;
    if (has_op()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->op());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawJoin::MergeFrom(const RawJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_partner()) {
      mutable_partner()->::gunir::compiler::RawTable::MergeFrom(from.partner());
    }
    if (from.has_expression()) {
      mutable_expression()->::gunir::compiler::RawExpression::MergeFrom(from.expression());
    }
    if (from.has_op()) {
      set_op(from.op());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawJoin::CopyFrom(const RawJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_partner()) {
    if (!this->partner().IsInitialized()) return false;
  }
  if (has_expression()) {
    if (!this->expression().IsInitialized()) return false;
  }
  return true;
}

void RawJoin::Swap(RawJoin* other) {
  if (other != this) {
    std::swap(partner_, other->partner_);
    std::swap(expression_, other->expression_);
    std::swap(op_, other->op_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawJoin_descriptor_;
  metadata.reflection = RawJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Limit::kStartFieldNumber;
const int Limit::kNumberFieldNumber;
#endif  // !_MSC_VER

Limit::Limit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Limit::InitAsDefaultInstance() {
}

Limit::Limit(const Limit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Limit::SharedCtor() {
  _cached_size_ = 0;
  start_ = 0;
  number_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Limit::~Limit() {
  SharedDtor();
}

void Limit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Limit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Limit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Limit_descriptor_;
}

const Limit& Limit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

Limit* Limit::default_instance_ = NULL;

Limit* Limit::New() const {
  return new Limit;
}

void Limit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_ = 0;
    number_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Limit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 start = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_number;
        break;
      }
      
      // required int32 number = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Limit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start(), output);
  }
  
  // required int32 number = 2;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->number(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Limit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start(), target);
  }
  
  // required int32 number = 2;
  if (has_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->number(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Limit::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start());
    }
    
    // required int32 number = 2;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->number());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Limit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Limit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Limit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Limit::MergeFrom(const Limit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      set_start(from.start());
    }
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Limit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Limit::CopyFrom(const Limit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Limit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  return true;
}

void Limit::Swap(Limit* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    std::swap(number_, other->number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Limit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Limit_descriptor_;
  metadata.reflection = Limit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawWithin::kIsRecordFieldNumber;
const int RawWithin::kColumnFieldNumber;
#endif  // !_MSC_VER

RawWithin::RawWithin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawWithin::InitAsDefaultInstance() {
  column_ = const_cast< ::gunir::compiler::ColumnPath*>(&::gunir::compiler::ColumnPath::default_instance());
}

RawWithin::RawWithin(const RawWithin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawWithin::SharedCtor() {
  _cached_size_ = 0;
  is_record_ = false;
  column_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawWithin::~RawWithin() {
  SharedDtor();
}

void RawWithin::SharedDtor() {
  if (this != default_instance_) {
    delete column_;
  }
}

void RawWithin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawWithin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawWithin_descriptor_;
}

const RawWithin& RawWithin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawWithin* RawWithin::default_instance_ = NULL;

RawWithin* RawWithin::New() const {
  return new RawWithin;
}

void RawWithin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    is_record_ = false;
    if (has_column()) {
      if (column_ != NULL) column_->::gunir::compiler::ColumnPath::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawWithin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool is_record = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_record_)));
          set_has_is_record();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_column;
        break;
      }
      
      // optional .gunir.compiler.ColumnPath column = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_column:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_column()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawWithin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool is_record = 1;
  if (has_is_record()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->is_record(), output);
  }
  
  // optional .gunir.compiler.ColumnPath column = 2;
  if (has_column()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->column(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawWithin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool is_record = 1;
  if (has_is_record()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->is_record(), target);
  }
  
  // optional .gunir.compiler.ColumnPath column = 2;
  if (has_column()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->column(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawWithin::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool is_record = 1;
    if (has_is_record()) {
      total_size += 1 + 1;
    }
    
    // optional .gunir.compiler.ColumnPath column = 2;
    if (has_column()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->column());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawWithin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawWithin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawWithin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawWithin::MergeFrom(const RawWithin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_is_record()) {
      set_is_record(from.is_record());
    }
    if (from.has_column()) {
      mutable_column()->::gunir::compiler::ColumnPath::MergeFrom(from.column());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawWithin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawWithin::CopyFrom(const RawWithin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawWithin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_column()) {
    if (!this->column().IsInitialized()) return false;
  }
  return true;
}

void RawWithin::Swap(RawWithin* other) {
  if (other != this) {
    std::swap(is_record_, other->is_record_);
    std::swap(column_, other->column_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawWithin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawWithin_descriptor_;
  metadata.reflection = RawWithin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawTarget::kExpressionFieldNumber;
const int RawTarget::kWithinFieldNumber;
const int RawTarget::kAliasFieldNumber;
#endif  // !_MSC_VER

RawTarget::RawTarget()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawTarget::InitAsDefaultInstance() {
  expression_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
  within_ = const_cast< ::gunir::compiler::RawWithin*>(&::gunir::compiler::RawWithin::default_instance());
  alias_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

RawTarget::RawTarget(const RawTarget& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawTarget::SharedCtor() {
  _cached_size_ = 0;
  expression_ = NULL;
  within_ = NULL;
  alias_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawTarget::~RawTarget() {
  SharedDtor();
}

void RawTarget::SharedDtor() {
  if (this != default_instance_) {
    delete expression_;
    delete within_;
    delete alias_;
  }
}

void RawTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawTarget::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawTarget_descriptor_;
}

const RawTarget& RawTarget::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawTarget* RawTarget::default_instance_ = NULL;

RawTarget* RawTarget::New() const {
  return new RawTarget;
}

void RawTarget::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_expression()) {
      if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
    }
    if (has_within()) {
      if (within_ != NULL) within_->::gunir::compiler::RawWithin::Clear();
    }
    if (has_alias()) {
      if (alias_ != NULL) alias_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.RawExpression expression = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expression()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_within;
        break;
      }
      
      // optional .gunir.compiler.RawWithin within = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_within:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_within()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_alias;
        break;
      }
      
      // optional .gunir.compiler.StringMessage alias = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alias()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.RawExpression expression = 1;
  if (has_expression()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expression(), output);
  }
  
  // optional .gunir.compiler.RawWithin within = 2;
  if (has_within()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->within(), output);
  }
  
  // optional .gunir.compiler.StringMessage alias = 3;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->alias(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawTarget::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.RawExpression expression = 1;
  if (has_expression()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expression(), target);
  }
  
  // optional .gunir.compiler.RawWithin within = 2;
  if (has_within()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->within(), target);
  }
  
  // optional .gunir.compiler.StringMessage alias = 3;
  if (has_alias()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->alias(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawTarget::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.RawExpression expression = 1;
    if (has_expression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expression());
    }
    
    // optional .gunir.compiler.RawWithin within = 2;
    if (has_within()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->within());
    }
    
    // optional .gunir.compiler.StringMessage alias = 3;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->alias());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawTarget::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawTarget* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawTarget*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawTarget::MergeFrom(const RawTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_expression()) {
      mutable_expression()->::gunir::compiler::RawExpression::MergeFrom(from.expression());
    }
    if (from.has_within()) {
      mutable_within()->::gunir::compiler::RawWithin::MergeFrom(from.within());
    }
    if (from.has_alias()) {
      mutable_alias()->::gunir::compiler::StringMessage::MergeFrom(from.alias());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawTarget::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawTarget::CopyFrom(const RawTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawTarget::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_expression()) {
    if (!this->expression().IsInitialized()) return false;
  }
  if (has_within()) {
    if (!this->within().IsInitialized()) return false;
  }
  if (has_alias()) {
    if (!this->alias().IsInitialized()) return false;
  }
  return true;
}

void RawTarget::Swap(RawTarget* other) {
  if (other != this) {
    std::swap(expression_, other->expression_);
    std::swap(within_, other->within_);
    std::swap(alias_, other->alias_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawTarget::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawTarget_descriptor_;
  metadata.reflection = RawTarget_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawTargetList::kTargetListFieldNumber;
const int RawTargetList::kTargetIsStarFieldNumber;
#endif  // !_MSC_VER

RawTargetList::RawTargetList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawTargetList::InitAsDefaultInstance() {
}

RawTargetList::RawTargetList(const RawTargetList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawTargetList::SharedCtor() {
  _cached_size_ = 0;
  target_is_star_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawTargetList::~RawTargetList() {
  SharedDtor();
}

void RawTargetList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RawTargetList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawTargetList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawTargetList_descriptor_;
}

const RawTargetList& RawTargetList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawTargetList* RawTargetList::default_instance_ = NULL;

RawTargetList* RawTargetList::New() const {
  return new RawTargetList;
}

void RawTargetList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    target_is_star_ = false;
  }
  target_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawTargetList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.RawTarget target_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_target_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_target_list;
        if (input->ExpectTag(16)) goto parse_target_is_star;
        break;
      }
      
      // required bool target_is_star = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_is_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &target_is_star_)));
          set_has_target_is_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawTargetList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.RawTarget target_list = 1;
  for (int i = 0; i < this->target_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->target_list(i), output);
  }
  
  // required bool target_is_star = 2;
  if (has_target_is_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->target_is_star(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawTargetList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.RawTarget target_list = 1;
  for (int i = 0; i < this->target_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->target_list(i), target);
  }
  
  // required bool target_is_star = 2;
  if (has_target_is_star()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->target_is_star(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawTargetList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bool target_is_star = 2;
    if (has_target_is_star()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .gunir.compiler.RawTarget target_list = 1;
  total_size += 1 * this->target_list_size();
  for (int i = 0; i < this->target_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->target_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawTargetList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawTargetList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawTargetList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawTargetList::MergeFrom(const RawTargetList& from) {
  GOOGLE_CHECK_NE(&from, this);
  target_list_.MergeFrom(from.target_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_target_is_star()) {
      set_target_is_star(from.target_is_star());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawTargetList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawTargetList::CopyFrom(const RawTargetList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawTargetList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  
  for (int i = 0; i < target_list_size(); i++) {
    if (!this->target_list(i).IsInitialized()) return false;
  }
  return true;
}

void RawTargetList::Swap(RawTargetList* other) {
  if (other != this) {
    target_list_.Swap(&other->target_list_);
    std::swap(target_is_star_, other->target_is_star_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawTargetList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawTargetList_descriptor_;
  metadata.reflection = RawTargetList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawTable::kTableNameFieldNumber;
const int RawTable::kSelectStmtFieldNumber;
const int RawTable::kAliasFieldNumber;
#endif  // !_MSC_VER

RawTable::RawTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawTable::InitAsDefaultInstance() {
  table_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  select_stmt_ = const_cast< ::gunir::compiler::SelectStmt*>(&::gunir::compiler::SelectStmt::default_instance());
  alias_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

RawTable::RawTable(const RawTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawTable::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  select_stmt_ = NULL;
  alias_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawTable::~RawTable() {
  SharedDtor();
}

void RawTable::SharedDtor() {
  if (this != default_instance_) {
    delete table_name_;
    delete select_stmt_;
    delete alias_;
  }
}

void RawTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawTable_descriptor_;
}

const RawTable& RawTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawTable* RawTable::default_instance_ = NULL;

RawTable* RawTable::New() const {
  return new RawTable;
}

void RawTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_select_stmt()) {
      if (select_stmt_ != NULL) select_stmt_->::gunir::compiler::SelectStmt::Clear();
    }
    if (has_alias()) {
      if (alias_ != NULL) alias_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.StringMessage table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_select_stmt;
        break;
      }
      
      // optional .gunir.compiler.SelectStmt select_stmt = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_select_stmt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_select_stmt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_alias;
        break;
      }
      
      // optional .gunir.compiler.StringMessage alias = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alias()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }
  
  // optional .gunir.compiler.SelectStmt select_stmt = 2;
  if (has_select_stmt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->select_stmt(), output);
  }
  
  // optional .gunir.compiler.StringMessage alias = 9;
  if (has_alias()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->alias(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }
  
  // optional .gunir.compiler.SelectStmt select_stmt = 2;
  if (has_select_stmt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->select_stmt(), target);
  }
  
  // optional .gunir.compiler.StringMessage alias = 9;
  if (has_alias()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->alias(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawTable::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.StringMessage table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }
    
    // optional .gunir.compiler.SelectStmt select_stmt = 2;
    if (has_select_stmt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->select_stmt());
    }
    
    // optional .gunir.compiler.StringMessage alias = 9;
    if (has_alias()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->alias());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawTable::MergeFrom(const RawTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::gunir::compiler::StringMessage::MergeFrom(from.table_name());
    }
    if (from.has_select_stmt()) {
      mutable_select_stmt()->::gunir::compiler::SelectStmt::MergeFrom(from.select_stmt());
    }
    if (from.has_alias()) {
      mutable_alias()->::gunir::compiler::StringMessage::MergeFrom(from.alias());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawTable::CopyFrom(const RawTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawTable::IsInitialized() const {
  
  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  if (has_select_stmt()) {
    if (!this->select_stmt().IsInitialized()) return false;
  }
  if (has_alias()) {
    if (!this->alias().IsInitialized()) return false;
  }
  return true;
}

void RawTable::Swap(RawTable* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(select_stmt_, other->select_stmt_);
    std::swap(alias_, other->alias_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawTable_descriptor_;
  metadata.reflection = RawTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RawTableList::kTableListFieldNumber;
#endif  // !_MSC_VER

RawTableList::RawTableList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RawTableList::InitAsDefaultInstance() {
}

RawTableList::RawTableList(const RawTableList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RawTableList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RawTableList::~RawTableList() {
  SharedDtor();
}

void RawTableList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RawTableList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RawTableList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RawTableList_descriptor_;
}

const RawTableList& RawTableList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

RawTableList* RawTableList::default_instance_ = NULL;

RawTableList* RawTableList::New() const {
  return new RawTableList;
}

void RawTableList::Clear() {
  table_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RawTableList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .gunir.compiler.RawTable table_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_table_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_table_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RawTableList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .gunir.compiler.RawTable table_list = 1;
  for (int i = 0; i < this->table_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_list(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RawTableList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .gunir.compiler.RawTable table_list = 1;
  for (int i = 0; i < this->table_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_list(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RawTableList::ByteSize() const {
  int total_size = 0;
  
  // repeated .gunir.compiler.RawTable table_list = 1;
  total_size += 1 * this->table_list_size();
  for (int i = 0; i < this->table_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->table_list(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RawTableList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RawTableList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RawTableList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RawTableList::MergeFrom(const RawTableList& from) {
  GOOGLE_CHECK_NE(&from, this);
  table_list_.MergeFrom(from.table_list_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RawTableList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RawTableList::CopyFrom(const RawTableList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RawTableList::IsInitialized() const {
  
  for (int i = 0; i < table_list_size(); i++) {
    if (!this->table_list(i).IsInitialized()) return false;
  }
  return true;
}

void RawTableList::Swap(RawTableList* other) {
  if (other != this) {
    table_list_.Swap(&other->table_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RawTableList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RawTableList_descriptor_;
  metadata.reflection = RawTableList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SelectStmt::kTargetListFieldNumber;
const int SelectStmt::kFromListFieldNumber;
const int SelectStmt::kWhereClauseFieldNumber;
const int SelectStmt::kJoinFieldNumber;
const int SelectStmt::kGroupbyFieldNumber;
const int SelectStmt::kHavingFieldNumber;
const int SelectStmt::kOrderbyFieldNumber;
const int SelectStmt::kLimitFieldNumber;
#endif  // !_MSC_VER

SelectStmt::SelectStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SelectStmt::InitAsDefaultInstance() {
  target_list_ = const_cast< ::gunir::compiler::RawTargetList*>(&::gunir::compiler::RawTargetList::default_instance());
  from_list_ = const_cast< ::gunir::compiler::RawTableList*>(&::gunir::compiler::RawTableList::default_instance());
  where_clause_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
  join_ = const_cast< ::gunir::compiler::RawJoin*>(&::gunir::compiler::RawJoin::default_instance());
  groupby_ = const_cast< ::gunir::compiler::ColumnPathList*>(&::gunir::compiler::ColumnPathList::default_instance());
  having_ = const_cast< ::gunir::compiler::RawExpression*>(&::gunir::compiler::RawExpression::default_instance());
  orderby_ = const_cast< ::gunir::compiler::OrderColumnPathList*>(&::gunir::compiler::OrderColumnPathList::default_instance());
  limit_ = const_cast< ::gunir::compiler::Limit*>(&::gunir::compiler::Limit::default_instance());
}

SelectStmt::SelectStmt(const SelectStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SelectStmt::SharedCtor() {
  _cached_size_ = 0;
  target_list_ = NULL;
  from_list_ = NULL;
  where_clause_ = NULL;
  join_ = NULL;
  groupby_ = NULL;
  having_ = NULL;
  orderby_ = NULL;
  limit_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SelectStmt::~SelectStmt() {
  SharedDtor();
}

void SelectStmt::SharedDtor() {
  if (this != default_instance_) {
    delete target_list_;
    delete from_list_;
    delete where_clause_;
    delete join_;
    delete groupby_;
    delete having_;
    delete orderby_;
    delete limit_;
  }
}

void SelectStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SelectStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SelectStmt_descriptor_;
}

const SelectStmt& SelectStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

SelectStmt* SelectStmt::default_instance_ = NULL;

SelectStmt* SelectStmt::New() const {
  return new SelectStmt;
}

void SelectStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_target_list()) {
      if (target_list_ != NULL) target_list_->::gunir::compiler::RawTargetList::Clear();
    }
    if (has_from_list()) {
      if (from_list_ != NULL) from_list_->::gunir::compiler::RawTableList::Clear();
    }
    if (has_where_clause()) {
      if (where_clause_ != NULL) where_clause_->::gunir::compiler::RawExpression::Clear();
    }
    if (has_join()) {
      if (join_ != NULL) join_->::gunir::compiler::RawJoin::Clear();
    }
    if (has_groupby()) {
      if (groupby_ != NULL) groupby_->::gunir::compiler::ColumnPathList::Clear();
    }
    if (has_having()) {
      if (having_ != NULL) having_->::gunir::compiler::RawExpression::Clear();
    }
    if (has_orderby()) {
      if (orderby_ != NULL) orderby_->::gunir::compiler::OrderColumnPathList::Clear();
    }
    if (has_limit()) {
      if (limit_ != NULL) limit_->::gunir::compiler::Limit::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SelectStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.RawTargetList target_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_target_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_from_list;
        break;
      }
      
      // required .gunir.compiler.RawTableList from_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_from_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_where_clause;
        break;
      }
      
      // optional .gunir.compiler.RawExpression where_clause = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_where_clause:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_where_clause()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_join;
        break;
      }
      
      // optional .gunir.compiler.RawJoin join = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_join:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_join()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_groupby;
        break;
      }
      
      // optional .gunir.compiler.ColumnPathList groupby = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_groupby:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_groupby()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_having;
        break;
      }
      
      // optional .gunir.compiler.RawExpression having = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_having:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_having()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_orderby;
        break;
      }
      
      // optional .gunir.compiler.OrderColumnPathList orderby = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_orderby:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_orderby()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_limit;
        break;
      }
      
      // optional .gunir.compiler.Limit limit = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limit()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SelectStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.RawTargetList target_list = 1;
  if (has_target_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->target_list(), output);
  }
  
  // required .gunir.compiler.RawTableList from_list = 2;
  if (has_from_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->from_list(), output);
  }
  
  // optional .gunir.compiler.RawExpression where_clause = 3;
  if (has_where_clause()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->where_clause(), output);
  }
  
  // optional .gunir.compiler.RawJoin join = 4;
  if (has_join()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->join(), output);
  }
  
  // optional .gunir.compiler.ColumnPathList groupby = 5;
  if (has_groupby()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->groupby(), output);
  }
  
  // optional .gunir.compiler.RawExpression having = 6;
  if (has_having()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->having(), output);
  }
  
  // optional .gunir.compiler.OrderColumnPathList orderby = 7;
  if (has_orderby()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->orderby(), output);
  }
  
  // optional .gunir.compiler.Limit limit = 8;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->limit(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SelectStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.RawTargetList target_list = 1;
  if (has_target_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->target_list(), target);
  }
  
  // required .gunir.compiler.RawTableList from_list = 2;
  if (has_from_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->from_list(), target);
  }
  
  // optional .gunir.compiler.RawExpression where_clause = 3;
  if (has_where_clause()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->where_clause(), target);
  }
  
  // optional .gunir.compiler.RawJoin join = 4;
  if (has_join()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->join(), target);
  }
  
  // optional .gunir.compiler.ColumnPathList groupby = 5;
  if (has_groupby()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->groupby(), target);
  }
  
  // optional .gunir.compiler.RawExpression having = 6;
  if (has_having()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->having(), target);
  }
  
  // optional .gunir.compiler.OrderColumnPathList orderby = 7;
  if (has_orderby()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->orderby(), target);
  }
  
  // optional .gunir.compiler.Limit limit = 8;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->limit(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SelectStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.RawTargetList target_list = 1;
    if (has_target_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->target_list());
    }
    
    // required .gunir.compiler.RawTableList from_list = 2;
    if (has_from_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->from_list());
    }
    
    // optional .gunir.compiler.RawExpression where_clause = 3;
    if (has_where_clause()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->where_clause());
    }
    
    // optional .gunir.compiler.RawJoin join = 4;
    if (has_join()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->join());
    }
    
    // optional .gunir.compiler.ColumnPathList groupby = 5;
    if (has_groupby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->groupby());
    }
    
    // optional .gunir.compiler.RawExpression having = 6;
    if (has_having()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->having());
    }
    
    // optional .gunir.compiler.OrderColumnPathList orderby = 7;
    if (has_orderby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->orderby());
    }
    
    // optional .gunir.compiler.Limit limit = 8;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limit());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SelectStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SelectStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SelectStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SelectStmt::MergeFrom(const SelectStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_list()) {
      mutable_target_list()->::gunir::compiler::RawTargetList::MergeFrom(from.target_list());
    }
    if (from.has_from_list()) {
      mutable_from_list()->::gunir::compiler::RawTableList::MergeFrom(from.from_list());
    }
    if (from.has_where_clause()) {
      mutable_where_clause()->::gunir::compiler::RawExpression::MergeFrom(from.where_clause());
    }
    if (from.has_join()) {
      mutable_join()->::gunir::compiler::RawJoin::MergeFrom(from.join());
    }
    if (from.has_groupby()) {
      mutable_groupby()->::gunir::compiler::ColumnPathList::MergeFrom(from.groupby());
    }
    if (from.has_having()) {
      mutable_having()->::gunir::compiler::RawExpression::MergeFrom(from.having());
    }
    if (from.has_orderby()) {
      mutable_orderby()->::gunir::compiler::OrderColumnPathList::MergeFrom(from.orderby());
    }
    if (from.has_limit()) {
      mutable_limit()->::gunir::compiler::Limit::MergeFrom(from.limit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SelectStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SelectStmt::CopyFrom(const SelectStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectStmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_target_list()) {
    if (!this->target_list().IsInitialized()) return false;
  }
  if (has_from_list()) {
    if (!this->from_list().IsInitialized()) return false;
  }
  if (has_where_clause()) {
    if (!this->where_clause().IsInitialized()) return false;
  }
  if (has_join()) {
    if (!this->join().IsInitialized()) return false;
  }
  if (has_groupby()) {
    if (!this->groupby().IsInitialized()) return false;
  }
  if (has_having()) {
    if (!this->having().IsInitialized()) return false;
  }
  if (has_orderby()) {
    if (!this->orderby().IsInitialized()) return false;
  }
  if (has_limit()) {
    if (!this->limit().IsInitialized()) return false;
  }
  return true;
}

void SelectStmt::Swap(SelectStmt* other) {
  if (other != this) {
    std::swap(target_list_, other->target_list_);
    std::swap(from_list_, other->from_list_);
    std::swap(where_clause_, other->where_clause_);
    std::swap(join_, other->join_);
    std::swap(groupby_, other->groupby_);
    std::swap(having_, other->having_);
    std::swap(orderby_, other->orderby_);
    std::swap(limit_, other->limit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SelectStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SelectStmt_descriptor_;
  metadata.reflection = SelectStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateTableStmt::kTableNameFieldNumber;
const int CreateTableStmt::kInputPathFieldNumber;
const int CreateTableStmt::kTableSchemaFieldNumber;
const int CreateTableStmt::kMessageNameFieldNumber;
const int CreateTableStmt::kCharsetEncodingFieldNumber;
const int CreateTableStmt::kTableTypeFieldNumber;
#endif  // !_MSC_VER

CreateTableStmt::CreateTableStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CreateTableStmt::InitAsDefaultInstance() {
  table_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  input_path_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  table_schema_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  message_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  charset_encoding_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  table_type_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

CreateTableStmt::CreateTableStmt(const CreateTableStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CreateTableStmt::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  input_path_ = NULL;
  table_schema_ = NULL;
  message_name_ = NULL;
  charset_encoding_ = NULL;
  table_type_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateTableStmt::~CreateTableStmt() {
  SharedDtor();
}

void CreateTableStmt::SharedDtor() {
  if (this != default_instance_) {
    delete table_name_;
    delete input_path_;
    delete table_schema_;
    delete message_name_;
    delete charset_encoding_;
    delete table_type_;
  }
}

void CreateTableStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateTableStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateTableStmt_descriptor_;
}

const CreateTableStmt& CreateTableStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

CreateTableStmt* CreateTableStmt::default_instance_ = NULL;

CreateTableStmt* CreateTableStmt::New() const {
  return new CreateTableStmt;
}

void CreateTableStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_input_path()) {
      if (input_path_ != NULL) input_path_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_table_schema()) {
      if (table_schema_ != NULL) table_schema_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_message_name()) {
      if (message_name_ != NULL) message_name_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_charset_encoding()) {
      if (charset_encoding_ != NULL) charset_encoding_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_table_type()) {
      if (table_type_ != NULL) table_type_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateTableStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.StringMessage table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input_path;
        break;
      }
      
      // required .gunir.compiler.StringMessage input_path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_table_schema;
        break;
      }
      
      // required .gunir.compiler.StringMessage table_schema = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table_schema:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_schema()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_message_name;
        break;
      }
      
      // required .gunir.compiler.StringMessage message_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_message_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_charset_encoding;
        break;
      }
      
      // optional .gunir.compiler.StringMessage charset_encoding = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charset_encoding:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_charset_encoding()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_table_type;
        break;
      }
      
      // optional .gunir.compiler.StringMessage table_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_table_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateTableStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }
  
  // required .gunir.compiler.StringMessage input_path = 2;
  if (has_input_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->input_path(), output);
  }
  
  // required .gunir.compiler.StringMessage table_schema = 3;
  if (has_table_schema()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->table_schema(), output);
  }
  
  // required .gunir.compiler.StringMessage message_name = 4;
  if (has_message_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->message_name(), output);
  }
  
  // optional .gunir.compiler.StringMessage charset_encoding = 5;
  if (has_charset_encoding()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->charset_encoding(), output);
  }
  
  // optional .gunir.compiler.StringMessage table_type = 6;
  if (has_table_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->table_type(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CreateTableStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }
  
  // required .gunir.compiler.StringMessage input_path = 2;
  if (has_input_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->input_path(), target);
  }
  
  // required .gunir.compiler.StringMessage table_schema = 3;
  if (has_table_schema()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->table_schema(), target);
  }
  
  // required .gunir.compiler.StringMessage message_name = 4;
  if (has_message_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->message_name(), target);
  }
  
  // optional .gunir.compiler.StringMessage charset_encoding = 5;
  if (has_charset_encoding()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->charset_encoding(), target);
  }
  
  // optional .gunir.compiler.StringMessage table_type = 6;
  if (has_table_type()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->table_type(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CreateTableStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.StringMessage table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }
    
    // required .gunir.compiler.StringMessage input_path = 2;
    if (has_input_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_path());
    }
    
    // required .gunir.compiler.StringMessage table_schema = 3;
    if (has_table_schema()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_schema());
    }
    
    // required .gunir.compiler.StringMessage message_name = 4;
    if (has_message_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->message_name());
    }
    
    // optional .gunir.compiler.StringMessage charset_encoding = 5;
    if (has_charset_encoding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->charset_encoding());
    }
    
    // optional .gunir.compiler.StringMessage table_type = 6;
    if (has_table_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_type());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateTableStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateTableStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateTableStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateTableStmt::MergeFrom(const CreateTableStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::gunir::compiler::StringMessage::MergeFrom(from.table_name());
    }
    if (from.has_input_path()) {
      mutable_input_path()->::gunir::compiler::StringMessage::MergeFrom(from.input_path());
    }
    if (from.has_table_schema()) {
      mutable_table_schema()->::gunir::compiler::StringMessage::MergeFrom(from.table_schema());
    }
    if (from.has_message_name()) {
      mutable_message_name()->::gunir::compiler::StringMessage::MergeFrom(from.message_name());
    }
    if (from.has_charset_encoding()) {
      mutable_charset_encoding()->::gunir::compiler::StringMessage::MergeFrom(from.charset_encoding());
    }
    if (from.has_table_type()) {
      mutable_table_type()->::gunir::compiler::StringMessage::MergeFrom(from.table_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateTableStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateTableStmt::CopyFrom(const CreateTableStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateTableStmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  if (has_input_path()) {
    if (!this->input_path().IsInitialized()) return false;
  }
  if (has_table_schema()) {
    if (!this->table_schema().IsInitialized()) return false;
  }
  if (has_message_name()) {
    if (!this->message_name().IsInitialized()) return false;
  }
  if (has_charset_encoding()) {
    if (!this->charset_encoding().IsInitialized()) return false;
  }
  if (has_table_type()) {
    if (!this->table_type().IsInitialized()) return false;
  }
  return true;
}

void CreateTableStmt::Swap(CreateTableStmt* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(input_path_, other->input_path_);
    std::swap(table_schema_, other->table_schema_);
    std::swap(message_name_, other->message_name_);
    std::swap(charset_encoding_, other->charset_encoding_);
    std::swap(table_type_, other->table_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateTableStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateTableStmt_descriptor_;
  metadata.reflection = CreateTableStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DefineTableStmt::kTableNameFieldNumber;
const int DefineTableStmt::kInputPathFieldNumber;
#endif  // !_MSC_VER

DefineTableStmt::DefineTableStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DefineTableStmt::InitAsDefaultInstance() {
  table_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
  input_path_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

DefineTableStmt::DefineTableStmt(const DefineTableStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DefineTableStmt::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  input_path_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DefineTableStmt::~DefineTableStmt() {
  SharedDtor();
}

void DefineTableStmt::SharedDtor() {
  if (this != default_instance_) {
    delete table_name_;
    delete input_path_;
  }
}

void DefineTableStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DefineTableStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DefineTableStmt_descriptor_;
}

const DefineTableStmt& DefineTableStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

DefineTableStmt* DefineTableStmt::default_instance_ = NULL;

DefineTableStmt* DefineTableStmt::New() const {
  return new DefineTableStmt;
}

void DefineTableStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
    }
    if (has_input_path()) {
      if (input_path_ != NULL) input_path_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DefineTableStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.StringMessage table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input_path;
        break;
      }
      
      // required .gunir.compiler.StringMessage input_path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DefineTableStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }
  
  // required .gunir.compiler.StringMessage input_path = 2;
  if (has_input_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->input_path(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DefineTableStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }
  
  // required .gunir.compiler.StringMessage input_path = 2;
  if (has_input_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->input_path(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DefineTableStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.StringMessage table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }
    
    // required .gunir.compiler.StringMessage input_path = 2;
    if (has_input_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_path());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DefineTableStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DefineTableStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DefineTableStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DefineTableStmt::MergeFrom(const DefineTableStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::gunir::compiler::StringMessage::MergeFrom(from.table_name());
    }
    if (from.has_input_path()) {
      mutable_input_path()->::gunir::compiler::StringMessage::MergeFrom(from.input_path());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DefineTableStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DefineTableStmt::CopyFrom(const DefineTableStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DefineTableStmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  if (has_input_path()) {
    if (!this->input_path().IsInitialized()) return false;
  }
  return true;
}

void DefineTableStmt::Swap(DefineTableStmt* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(input_path_, other->input_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DefineTableStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DefineTableStmt_descriptor_;
  metadata.reflection = DefineTableStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DropTableStmt::kTableNameFieldNumber;
#endif  // !_MSC_VER

DropTableStmt::DropTableStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DropTableStmt::InitAsDefaultInstance() {
  table_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

DropTableStmt::DropTableStmt(const DropTableStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DropTableStmt::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropTableStmt::~DropTableStmt() {
  SharedDtor();
}

void DropTableStmt::SharedDtor() {
  if (this != default_instance_) {
    delete table_name_;
  }
}

void DropTableStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DropTableStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DropTableStmt_descriptor_;
}

const DropTableStmt& DropTableStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

DropTableStmt* DropTableStmt::default_instance_ = NULL;

DropTableStmt* DropTableStmt::New() const {
  return new DropTableStmt;
}

void DropTableStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DropTableStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .gunir.compiler.StringMessage table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DropTableStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DropTableStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DropTableStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .gunir.compiler.StringMessage table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropTableStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DropTableStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DropTableStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DropTableStmt::MergeFrom(const DropTableStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::gunir::compiler::StringMessage::MergeFrom(from.table_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DropTableStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DropTableStmt::CopyFrom(const DropTableStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropTableStmt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  return true;
}

void DropTableStmt::Swap(DropTableStmt* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DropTableStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DropTableStmt_descriptor_;
  metadata.reflection = DropTableStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShowStmt::kTableNameFieldNumber;
#endif  // !_MSC_VER

ShowStmt::ShowStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShowStmt::InitAsDefaultInstance() {
  table_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

ShowStmt::ShowStmt(const ShowStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShowStmt::SharedCtor() {
  _cached_size_ = 0;
  table_name_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShowStmt::~ShowStmt() {
  SharedDtor();
}

void ShowStmt::SharedDtor() {
  if (this != default_instance_) {
    delete table_name_;
  }
}

void ShowStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShowStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShowStmt_descriptor_;
}

const ShowStmt& ShowStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

ShowStmt* ShowStmt::default_instance_ = NULL;

ShowStmt* ShowStmt::New() const {
  return new ShowStmt;
}

void ShowStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_table_name()) {
      if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShowStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.StringMessage table_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_table_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShowStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->table_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShowStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.StringMessage table_name = 1;
  if (has_table_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->table_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShowStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.StringMessage table_name = 1;
    if (has_table_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->table_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShowStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShowStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShowStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShowStmt::MergeFrom(const ShowStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_table_name()) {
      mutable_table_name()->::gunir::compiler::StringMessage::MergeFrom(from.table_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShowStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShowStmt::CopyFrom(const ShowStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowStmt::IsInitialized() const {
  
  if (has_table_name()) {
    if (!this->table_name().IsInitialized()) return false;
  }
  return true;
}

void ShowStmt::Swap(ShowStmt* other) {
  if (other != this) {
    std::swap(table_name_, other->table_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShowStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShowStmt_descriptor_;
  metadata.reflection = ShowStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HelpStmt::kCmdNameFieldNumber;
#endif  // !_MSC_VER

HelpStmt::HelpStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HelpStmt::InitAsDefaultInstance() {
  cmd_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

HelpStmt::HelpStmt(const HelpStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HelpStmt::SharedCtor() {
  _cached_size_ = 0;
  cmd_name_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HelpStmt::~HelpStmt() {
  SharedDtor();
}

void HelpStmt::SharedDtor() {
  if (this != default_instance_) {
    delete cmd_name_;
  }
}

void HelpStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HelpStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HelpStmt_descriptor_;
}

const HelpStmt& HelpStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

HelpStmt* HelpStmt::default_instance_ = NULL;

HelpStmt* HelpStmt::New() const {
  return new HelpStmt;
}

void HelpStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cmd_name()) {
      if (cmd_name_ != NULL) cmd_name_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HelpStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.StringMessage cmd_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cmd_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HelpStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  if (has_cmd_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cmd_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HelpStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  if (has_cmd_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cmd_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HelpStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.StringMessage cmd_name = 1;
    if (has_cmd_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cmd_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HelpStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HelpStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HelpStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HelpStmt::MergeFrom(const HelpStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd_name()) {
      mutable_cmd_name()->::gunir::compiler::StringMessage::MergeFrom(from.cmd_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HelpStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HelpStmt::CopyFrom(const HelpStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HelpStmt::IsInitialized() const {
  
  if (has_cmd_name()) {
    if (!this->cmd_name().IsInitialized()) return false;
  }
  return true;
}

void HelpStmt::Swap(HelpStmt* other) {
  if (other != this) {
    std::swap(cmd_name_, other->cmd_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HelpStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HelpStmt_descriptor_;
  metadata.reflection = HelpStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QuitStmt::kCmdNameFieldNumber;
#endif  // !_MSC_VER

QuitStmt::QuitStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void QuitStmt::InitAsDefaultInstance() {
  cmd_name_ = const_cast< ::gunir::compiler::StringMessage*>(&::gunir::compiler::StringMessage::default_instance());
}

QuitStmt::QuitStmt(const QuitStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void QuitStmt::SharedCtor() {
  _cached_size_ = 0;
  cmd_name_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuitStmt::~QuitStmt() {
  SharedDtor();
}

void QuitStmt::SharedDtor() {
  if (this != default_instance_) {
    delete cmd_name_;
  }
}

void QuitStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QuitStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QuitStmt_descriptor_;
}

const QuitStmt& QuitStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

QuitStmt* QuitStmt::default_instance_ = NULL;

QuitStmt* QuitStmt::New() const {
  return new QuitStmt;
}

void QuitStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cmd_name()) {
      if (cmd_name_ != NULL) cmd_name_->::gunir::compiler::StringMessage::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QuitStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.StringMessage cmd_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cmd_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QuitStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  if (has_cmd_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cmd_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* QuitStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  if (has_cmd_name()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cmd_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int QuitStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.StringMessage cmd_name = 1;
    if (has_cmd_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cmd_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuitStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QuitStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QuitStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QuitStmt::MergeFrom(const QuitStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd_name()) {
      mutable_cmd_name()->::gunir::compiler::StringMessage::MergeFrom(from.cmd_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QuitStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QuitStmt::CopyFrom(const QuitStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuitStmt::IsInitialized() const {
  
  if (has_cmd_name()) {
    if (!this->cmd_name().IsInitialized()) return false;
  }
  return true;
}

void QuitStmt::Swap(QuitStmt* other) {
  if (other != this) {
    std::swap(cmd_name_, other->cmd_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QuitStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QuitStmt_descriptor_;
  metadata.reflection = QuitStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HistoryStmt::kStartFieldNumber;
const int HistoryStmt::kSizeFieldNumber;
#endif  // !_MSC_VER

HistoryStmt::HistoryStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HistoryStmt::InitAsDefaultInstance() {
}

HistoryStmt::HistoryStmt(const HistoryStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HistoryStmt::SharedCtor() {
  _cached_size_ = 0;
  start_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HistoryStmt::~HistoryStmt() {
  SharedDtor();
}

void HistoryStmt::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HistoryStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HistoryStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HistoryStmt_descriptor_;
}

const HistoryStmt& HistoryStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

HistoryStmt* HistoryStmt::default_instance_ = NULL;

HistoryStmt* HistoryStmt::New() const {
  return new HistoryStmt;
}

void HistoryStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_ = 0;
    size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HistoryStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 start = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }
      
      // optional int32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HistoryStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start(), output);
  }
  
  // optional int32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HistoryStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start(), target);
  }
  
  // optional int32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->size(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HistoryStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start());
    }
    
    // optional int32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HistoryStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HistoryStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HistoryStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HistoryStmt::MergeFrom(const HistoryStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      set_start(from.start());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HistoryStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HistoryStmt::CopyFrom(const HistoryStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HistoryStmt::IsInitialized() const {
  
  return true;
}

void HistoryStmt::Swap(HistoryStmt* other) {
  if (other != this) {
    std::swap(start_, other->start_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HistoryStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HistoryStmt_descriptor_;
  metadata.reflection = HistoryStmt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QueryStmt::kSelectFieldNumber;
const int QueryStmt::kCreateFieldNumber;
const int QueryStmt::kDropFieldNumber;
const int QueryStmt::kHelpFieldNumber;
const int QueryStmt::kShowFieldNumber;
const int QueryStmt::kHistoryFieldNumber;
const int QueryStmt::kQuitFieldNumber;
const int QueryStmt::kDefineFieldNumber;
#endif  // !_MSC_VER

QueryStmt::QueryStmt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void QueryStmt::InitAsDefaultInstance() {
  select_ = const_cast< ::gunir::compiler::SelectStmt*>(&::gunir::compiler::SelectStmt::default_instance());
  create_ = const_cast< ::gunir::compiler::CreateTableStmt*>(&::gunir::compiler::CreateTableStmt::default_instance());
  drop_ = const_cast< ::gunir::compiler::DropTableStmt*>(&::gunir::compiler::DropTableStmt::default_instance());
  help_ = const_cast< ::gunir::compiler::HelpStmt*>(&::gunir::compiler::HelpStmt::default_instance());
  show_ = const_cast< ::gunir::compiler::ShowStmt*>(&::gunir::compiler::ShowStmt::default_instance());
  history_ = const_cast< ::gunir::compiler::HistoryStmt*>(&::gunir::compiler::HistoryStmt::default_instance());
  quit_ = const_cast< ::gunir::compiler::QuitStmt*>(&::gunir::compiler::QuitStmt::default_instance());
  define_ = const_cast< ::gunir::compiler::DefineTableStmt*>(&::gunir::compiler::DefineTableStmt::default_instance());
}

QueryStmt::QueryStmt(const QueryStmt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void QueryStmt::SharedCtor() {
  _cached_size_ = 0;
  select_ = NULL;
  create_ = NULL;
  drop_ = NULL;
  help_ = NULL;
  show_ = NULL;
  history_ = NULL;
  quit_ = NULL;
  define_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryStmt::~QueryStmt() {
  SharedDtor();
}

void QueryStmt::SharedDtor() {
  if (this != default_instance_) {
    delete select_;
    delete create_;
    delete drop_;
    delete help_;
    delete show_;
    delete history_;
    delete quit_;
    delete define_;
  }
}

void QueryStmt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QueryStmt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QueryStmt_descriptor_;
}

const QueryStmt& QueryStmt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_select_5fstmt_2eproto();  return *default_instance_;
}

QueryStmt* QueryStmt::default_instance_ = NULL;

QueryStmt* QueryStmt::New() const {
  return new QueryStmt;
}

void QueryStmt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_select()) {
      if (select_ != NULL) select_->::gunir::compiler::SelectStmt::Clear();
    }
    if (has_create()) {
      if (create_ != NULL) create_->::gunir::compiler::CreateTableStmt::Clear();
    }
    if (has_drop()) {
      if (drop_ != NULL) drop_->::gunir::compiler::DropTableStmt::Clear();
    }
    if (has_help()) {
      if (help_ != NULL) help_->::gunir::compiler::HelpStmt::Clear();
    }
    if (has_show()) {
      if (show_ != NULL) show_->::gunir::compiler::ShowStmt::Clear();
    }
    if (has_history()) {
      if (history_ != NULL) history_->::gunir::compiler::HistoryStmt::Clear();
    }
    if (has_quit()) {
      if (quit_ != NULL) quit_->::gunir::compiler::QuitStmt::Clear();
    }
    if (has_define()) {
      if (define_ != NULL) define_->::gunir::compiler::DefineTableStmt::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QueryStmt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gunir.compiler.SelectStmt select = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_select()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_create;
        break;
      }
      
      // optional .gunir.compiler.CreateTableStmt create = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_create:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_create()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_drop;
        break;
      }
      
      // optional .gunir.compiler.DropTableStmt drop = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_drop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_drop()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_help;
        break;
      }
      
      // optional .gunir.compiler.HelpStmt help = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_help:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_help()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_show;
        break;
      }
      
      // optional .gunir.compiler.ShowStmt show = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_show:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_show()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_history;
        break;
      }
      
      // optional .gunir.compiler.HistoryStmt history = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_history:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_history()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_quit;
        break;
      }
      
      // optional .gunir.compiler.QuitStmt quit = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_quit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_quit()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_define;
        break;
      }
      
      // optional .gunir.compiler.DefineTableStmt define = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_define:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_define()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QueryStmt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .gunir.compiler.SelectStmt select = 1;
  if (has_select()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->select(), output);
  }
  
  // optional .gunir.compiler.CreateTableStmt create = 2;
  if (has_create()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->create(), output);
  }
  
  // optional .gunir.compiler.DropTableStmt drop = 3;
  if (has_drop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->drop(), output);
  }
  
  // optional .gunir.compiler.HelpStmt help = 4;
  if (has_help()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->help(), output);
  }
  
  // optional .gunir.compiler.ShowStmt show = 5;
  if (has_show()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->show(), output);
  }
  
  // optional .gunir.compiler.HistoryStmt history = 6;
  if (has_history()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->history(), output);
  }
  
  // optional .gunir.compiler.QuitStmt quit = 7;
  if (has_quit()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->quit(), output);
  }
  
  // optional .gunir.compiler.DefineTableStmt define = 8;
  if (has_define()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->define(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* QueryStmt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .gunir.compiler.SelectStmt select = 1;
  if (has_select()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->select(), target);
  }
  
  // optional .gunir.compiler.CreateTableStmt create = 2;
  if (has_create()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->create(), target);
  }
  
  // optional .gunir.compiler.DropTableStmt drop = 3;
  if (has_drop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->drop(), target);
  }
  
  // optional .gunir.compiler.HelpStmt help = 4;
  if (has_help()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->help(), target);
  }
  
  // optional .gunir.compiler.ShowStmt show = 5;
  if (has_show()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->show(), target);
  }
  
  // optional .gunir.compiler.HistoryStmt history = 6;
  if (has_history()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->history(), target);
  }
  
  // optional .gunir.compiler.QuitStmt quit = 7;
  if (has_quit()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->quit(), target);
  }
  
  // optional .gunir.compiler.DefineTableStmt define = 8;
  if (has_define()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->define(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int QueryStmt::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gunir.compiler.SelectStmt select = 1;
    if (has_select()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->select());
    }
    
    // optional .gunir.compiler.CreateTableStmt create = 2;
    if (has_create()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->create());
    }
    
    // optional .gunir.compiler.DropTableStmt drop = 3;
    if (has_drop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->drop());
    }
    
    // optional .gunir.compiler.HelpStmt help = 4;
    if (has_help()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->help());
    }
    
    // optional .gunir.compiler.ShowStmt show = 5;
    if (has_show()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->show());
    }
    
    // optional .gunir.compiler.HistoryStmt history = 6;
    if (has_history()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->history());
    }
    
    // optional .gunir.compiler.QuitStmt quit = 7;
    if (has_quit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->quit());
    }
    
    // optional .gunir.compiler.DefineTableStmt define = 8;
    if (has_define()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->define());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryStmt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QueryStmt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QueryStmt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QueryStmt::MergeFrom(const QueryStmt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_select()) {
      mutable_select()->::gunir::compiler::SelectStmt::MergeFrom(from.select());
    }
    if (from.has_create()) {
      mutable_create()->::gunir::compiler::CreateTableStmt::MergeFrom(from.create());
    }
    if (from.has_drop()) {
      mutable_drop()->::gunir::compiler::DropTableStmt::MergeFrom(from.drop());
    }
    if (from.has_help()) {
      mutable_help()->::gunir::compiler::HelpStmt::MergeFrom(from.help());
    }
    if (from.has_show()) {
      mutable_show()->::gunir::compiler::ShowStmt::MergeFrom(from.show());
    }
    if (from.has_history()) {
      mutable_history()->::gunir::compiler::HistoryStmt::MergeFrom(from.history());
    }
    if (from.has_quit()) {
      mutable_quit()->::gunir::compiler::QuitStmt::MergeFrom(from.quit());
    }
    if (from.has_define()) {
      mutable_define()->::gunir::compiler::DefineTableStmt::MergeFrom(from.define());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QueryStmt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QueryStmt::CopyFrom(const QueryStmt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryStmt::IsInitialized() const {
  
  if (has_select()) {
    if (!this->select().IsInitialized()) return false;
  }
  if (has_create()) {
    if (!this->create().IsInitialized()) return false;
  }
  if (has_drop()) {
    if (!this->drop().IsInitialized()) return false;
  }
  if (has_help()) {
    if (!this->help().IsInitialized()) return false;
  }
  if (has_show()) {
    if (!this->show().IsInitialized()) return false;
  }
  if (has_quit()) {
    if (!this->quit().IsInitialized()) return false;
  }
  if (has_define()) {
    if (!this->define().IsInitialized()) return false;
  }
  return true;
}

void QueryStmt::Swap(QueryStmt* other) {
  if (other != this) {
    std::swap(select_, other->select_);
    std::swap(create_, other->create_);
    std::swap(drop_, other->drop_);
    std::swap(help_, other->help_);
    std::swap(show_, other->show_);
    std::swap(history_, other->history_);
    std::swap(quit_, other->quit_);
    std::swap(define_, other->define_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QueryStmt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QueryStmt_descriptor_;
  metadata.reflection = QueryStmt_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace compiler
}  // namespace gunir

// @@protoc_insertion_point(global_scope)
