// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: select_stmt.proto

#ifndef PROTOBUF_select_5fstmt_2eproto__INCLUDED
#define PROTOBUF_select_5fstmt_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace gunir {
namespace compiler {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_select_5fstmt_2eproto();
void protobuf_AssignDesc_select_5fstmt_2eproto();
void protobuf_ShutdownFile_select_5fstmt_2eproto();

class StringMessage;
class ColumnPath;
class ColumnPathList;
class OrderColumnPath;
class OrderColumnPathList;
class RawAtomicExpression;
class RawExpression;
class RawExpressionList;
class RawArguments;
class RawFunction;
class RawJoin;
class Limit;
class RawWithin;
class RawTarget;
class RawTargetList;
class RawTable;
class RawTableList;
class SelectStmt;
class CreateTableStmt;
class DefineTableStmt;
class DropTableStmt;
class ShowStmt;
class HelpStmt;
class QuitStmt;
class HistoryStmt;
class QueryStmt;

enum OrderType {
  kAsc = 1,
  kDesc = 2
};
bool OrderType_IsValid(int value);
const OrderType OrderType_MIN = kAsc;
const OrderType OrderType_MAX = kDesc;
const int OrderType_ARRAYSIZE = OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderType_descriptor();
inline const ::std::string& OrderType_Name(OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderType_descriptor(), value);
}
inline bool OrderType_Parse(
    const ::std::string& name, OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderType>(
    OrderType_descriptor(), name, value);
}
enum Operators {
  kAdd = 1,
  kSub = 2,
  kMul = 3,
  kDiv = 4,
  kRemainder = 5,
  kLogicalAnd = 6,
  kLogicalOr = 7,
  kLogicalNot = 8,
  kBitwiseAnd = 9,
  kBitwiseOr = 10,
  kBitwiseNot = 11,
  kBitwiseXor = 12,
  kBitwiseLeftShift = 13,
  kBitwiseRightShift = 14,
  kContains = 15,
  kGreaterEqual = 16,
  kGreater = 17,
  kLessEqual = 18,
  kLess = 19,
  kEqual = 20,
  kNotEqual = 21
};
bool Operators_IsValid(int value);
const Operators Operators_MIN = kAdd;
const Operators Operators_MAX = kNotEqual;
const int Operators_ARRAYSIZE = Operators_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operators_descriptor();
inline const ::std::string& Operators_Name(Operators value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operators_descriptor(), value);
}
inline bool Operators_Parse(
    const ::std::string& name, Operators* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operators>(
    Operators_descriptor(), name, value);
}
enum JoinOperator {
  kInner = 1,
  kLeftOuter = 2
};
bool JoinOperator_IsValid(int value);
const JoinOperator JoinOperator_MIN = kInner;
const JoinOperator JoinOperator_MAX = kLeftOuter;
const int JoinOperator_ARRAYSIZE = JoinOperator_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinOperator_descriptor();
inline const ::std::string& JoinOperator_Name(JoinOperator value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinOperator_descriptor(), value);
}
inline bool JoinOperator_Parse(
    const ::std::string& name, JoinOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinOperator>(
    JoinOperator_descriptor(), name, value);
}
// ===================================================================

class StringMessage : public ::google::protobuf::Message {
 public:
  StringMessage();
  virtual ~StringMessage();
  
  StringMessage(const StringMessage& from);
  
  inline StringMessage& operator=(const StringMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMessage& default_instance();
  
  void Swap(StringMessage* other);
  
  // implements Message ----------------------------------------------
  
  StringMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringMessage& from);
  void MergeFrom(const StringMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string char_string = 1;
  inline bool has_char_string() const;
  inline void clear_char_string();
  static const int kCharStringFieldNumber = 1;
  inline const ::std::string& char_string() const;
  inline void set_char_string(const ::std::string& value);
  inline void set_char_string(const char* value);
  inline void set_char_string(const char* value, size_t size);
  inline ::std::string* mutable_char_string();
  inline ::std::string* release_char_string();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.StringMessage)
 private:
  inline void set_has_char_string();
  inline void clear_has_char_string();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* char_string_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static StringMessage* default_instance_;
};
// -------------------------------------------------------------------

class ColumnPath : public ::google::protobuf::Message {
 public:
  ColumnPath();
  virtual ~ColumnPath();
  
  ColumnPath(const ColumnPath& from);
  
  inline ColumnPath& operator=(const ColumnPath& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnPath& default_instance();
  
  void Swap(ColumnPath* other);
  
  // implements Message ----------------------------------------------
  
  ColumnPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnPath& from);
  void MergeFrom(const ColumnPath& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.StringMessage field_list = 1;
  inline int field_list_size() const;
  inline void clear_field_list();
  static const int kFieldListFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& field_list(int index) const;
  inline ::gunir::compiler::StringMessage* mutable_field_list(int index);
  inline ::gunir::compiler::StringMessage* add_field_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::StringMessage >&
      field_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::StringMessage >*
      mutable_field_list();
  
  // optional bool has_distinct = 2;
  inline bool has_has_distinct() const;
  inline void clear_has_distinct();
  static const int kHasDistinctFieldNumber = 2;
  inline bool has_distinct() const;
  inline void set_has_distinct(bool value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.ColumnPath)
 private:
  inline void set_has_has_distinct();
  inline void clear_has_has_distinct();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::StringMessage > field_list_;
  bool has_distinct_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static ColumnPath* default_instance_;
};
// -------------------------------------------------------------------

class ColumnPathList : public ::google::protobuf::Message {
 public:
  ColumnPathList();
  virtual ~ColumnPathList();
  
  ColumnPathList(const ColumnPathList& from);
  
  inline ColumnPathList& operator=(const ColumnPathList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnPathList& default_instance();
  
  void Swap(ColumnPathList* other);
  
  // implements Message ----------------------------------------------
  
  ColumnPathList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ColumnPathList& from);
  void MergeFrom(const ColumnPathList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.ColumnPath path_list = 1;
  inline int path_list_size() const;
  inline void clear_path_list();
  static const int kPathListFieldNumber = 1;
  inline const ::gunir::compiler::ColumnPath& path_list(int index) const;
  inline ::gunir::compiler::ColumnPath* mutable_path_list(int index);
  inline ::gunir::compiler::ColumnPath* add_path_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::ColumnPath >&
      path_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::ColumnPath >*
      mutable_path_list();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.ColumnPathList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::ColumnPath > path_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static ColumnPathList* default_instance_;
};
// -------------------------------------------------------------------

class OrderColumnPath : public ::google::protobuf::Message {
 public:
  OrderColumnPath();
  virtual ~OrderColumnPath();
  
  OrderColumnPath(const OrderColumnPath& from);
  
  inline OrderColumnPath& operator=(const OrderColumnPath& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderColumnPath& default_instance();
  
  void Swap(OrderColumnPath* other);
  
  // implements Message ----------------------------------------------
  
  OrderColumnPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderColumnPath& from);
  void MergeFrom(const OrderColumnPath& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.ColumnPath path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::gunir::compiler::ColumnPath& path() const;
  inline ::gunir::compiler::ColumnPath* mutable_path();
  inline ::gunir::compiler::ColumnPath* release_path();
  
  // required .gunir.compiler.OrderType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline gunir::compiler::OrderType type() const;
  inline void set_type(gunir::compiler::OrderType value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.OrderColumnPath)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::ColumnPath* path_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static OrderColumnPath* default_instance_;
};
// -------------------------------------------------------------------

class OrderColumnPathList : public ::google::protobuf::Message {
 public:
  OrderColumnPathList();
  virtual ~OrderColumnPathList();
  
  OrderColumnPathList(const OrderColumnPathList& from);
  
  inline OrderColumnPathList& operator=(const OrderColumnPathList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderColumnPathList& default_instance();
  
  void Swap(OrderColumnPathList* other);
  
  // implements Message ----------------------------------------------
  
  OrderColumnPathList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderColumnPathList& from);
  void MergeFrom(const OrderColumnPathList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.OrderColumnPath path_list = 1;
  inline int path_list_size() const;
  inline void clear_path_list();
  static const int kPathListFieldNumber = 1;
  inline const ::gunir::compiler::OrderColumnPath& path_list(int index) const;
  inline ::gunir::compiler::OrderColumnPath* mutable_path_list(int index);
  inline ::gunir::compiler::OrderColumnPath* add_path_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::OrderColumnPath >&
      path_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::OrderColumnPath >*
      mutable_path_list();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.OrderColumnPathList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::OrderColumnPath > path_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static OrderColumnPathList* default_instance_;
};
// -------------------------------------------------------------------

class RawAtomicExpression : public ::google::protobuf::Message {
 public:
  RawAtomicExpression();
  virtual ~RawAtomicExpression();
  
  RawAtomicExpression(const RawAtomicExpression& from);
  
  inline RawAtomicExpression& operator=(const RawAtomicExpression& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawAtomicExpression& default_instance();
  
  void Swap(RawAtomicExpression* other);
  
  // implements Message ----------------------------------------------
  
  RawAtomicExpression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawAtomicExpression& from);
  void MergeFrom(const RawAtomicExpression& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.RawFunction function = 1;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline const ::gunir::compiler::RawFunction& function() const;
  inline ::gunir::compiler::RawFunction* mutable_function();
  inline ::gunir::compiler::RawFunction* release_function();
  
  // optional int64 integer = 2;
  inline bool has_integer() const;
  inline void clear_integer();
  static const int kIntegerFieldNumber = 2;
  inline ::google::protobuf::int64 integer() const;
  inline void set_integer(::google::protobuf::int64 value);
  
  // optional double floating = 3;
  inline bool has_floating() const;
  inline void clear_floating();
  static const int kFloatingFieldNumber = 3;
  inline double floating() const;
  inline void set_floating(double value);
  
  // optional bool boolean = 4;
  inline bool has_boolean() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 4;
  inline bool boolean() const;
  inline void set_boolean(bool value);
  
  // optional .gunir.compiler.StringMessage char_string = 5;
  inline bool has_char_string() const;
  inline void clear_char_string();
  static const int kCharStringFieldNumber = 5;
  inline const ::gunir::compiler::StringMessage& char_string() const;
  inline ::gunir::compiler::StringMessage* mutable_char_string();
  inline ::gunir::compiler::StringMessage* release_char_string();
  
  // optional .gunir.compiler.ColumnPath column = 6;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 6;
  inline const ::gunir::compiler::ColumnPath& column() const;
  inline ::gunir::compiler::ColumnPath* mutable_column();
  inline ::gunir::compiler::ColumnPath* release_column();
  
  // optional .gunir.compiler.RawExpression expression = 7;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 7;
  inline const ::gunir::compiler::RawExpression& expression() const;
  inline ::gunir::compiler::RawExpression* mutable_expression();
  inline ::gunir::compiler::RawExpression* release_expression();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawAtomicExpression)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_integer();
  inline void clear_has_integer();
  inline void set_has_floating();
  inline void clear_has_floating();
  inline void set_has_boolean();
  inline void clear_has_boolean();
  inline void set_has_char_string();
  inline void clear_has_char_string();
  inline void set_has_column();
  inline void clear_has_column();
  inline void set_has_expression();
  inline void clear_has_expression();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawFunction* function_;
  ::google::protobuf::int64 integer_;
  double floating_;
  ::gunir::compiler::StringMessage* char_string_;
  ::gunir::compiler::ColumnPath* column_;
  ::gunir::compiler::RawExpression* expression_;
  bool boolean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawAtomicExpression* default_instance_;
};
// -------------------------------------------------------------------

class RawExpression : public ::google::protobuf::Message {
 public:
  RawExpression();
  virtual ~RawExpression();
  
  RawExpression(const RawExpression& from);
  
  inline RawExpression& operator=(const RawExpression& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawExpression& default_instance();
  
  void Swap(RawExpression* other);
  
  // implements Message ----------------------------------------------
  
  RawExpression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawExpression& from);
  void MergeFrom(const RawExpression& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.RawExpression left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline const ::gunir::compiler::RawExpression& left() const;
  inline ::gunir::compiler::RawExpression* mutable_left();
  inline ::gunir::compiler::RawExpression* release_left();
  
  // optional .gunir.compiler.RawExpression right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline const ::gunir::compiler::RawExpression& right() const;
  inline ::gunir::compiler::RawExpression* mutable_right();
  inline ::gunir::compiler::RawExpression* release_right();
  
  // optional .gunir.compiler.RawAtomicExpression atomic = 3;
  inline bool has_atomic() const;
  inline void clear_atomic();
  static const int kAtomicFieldNumber = 3;
  inline const ::gunir::compiler::RawAtomicExpression& atomic() const;
  inline ::gunir::compiler::RawAtomicExpression* mutable_atomic();
  inline ::gunir::compiler::RawAtomicExpression* release_atomic();
  
  // optional .gunir.compiler.Operators op = 4;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 4;
  inline gunir::compiler::Operators op() const;
  inline void set_op(gunir::compiler::Operators value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawExpression)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_atomic();
  inline void clear_has_atomic();
  inline void set_has_op();
  inline void clear_has_op();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawExpression* left_;
  ::gunir::compiler::RawExpression* right_;
  ::gunir::compiler::RawAtomicExpression* atomic_;
  int op_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawExpression* default_instance_;
};
// -------------------------------------------------------------------

class RawExpressionList : public ::google::protobuf::Message {
 public:
  RawExpressionList();
  virtual ~RawExpressionList();
  
  RawExpressionList(const RawExpressionList& from);
  
  inline RawExpressionList& operator=(const RawExpressionList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawExpressionList& default_instance();
  
  void Swap(RawExpressionList* other);
  
  // implements Message ----------------------------------------------
  
  RawExpressionList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawExpressionList& from);
  void MergeFrom(const RawExpressionList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.RawExpression expr_list = 1;
  inline int expr_list_size() const;
  inline void clear_expr_list();
  static const int kExprListFieldNumber = 1;
  inline const ::gunir::compiler::RawExpression& expr_list(int index) const;
  inline ::gunir::compiler::RawExpression* mutable_expr_list(int index);
  inline ::gunir::compiler::RawExpression* add_expr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawExpression >&
      expr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawExpression >*
      mutable_expr_list();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawExpressionList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawExpression > expr_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawExpressionList* default_instance_;
};
// -------------------------------------------------------------------

class RawArguments : public ::google::protobuf::Message {
 public:
  RawArguments();
  virtual ~RawArguments();
  
  RawArguments(const RawArguments& from);
  
  inline RawArguments& operator=(const RawArguments& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawArguments& default_instance();
  
  void Swap(RawArguments* other);
  
  // implements Message ----------------------------------------------
  
  RawArguments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawArguments& from);
  void MergeFrom(const RawArguments& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.RawExpressionList arg_list = 1;
  inline bool has_arg_list() const;
  inline void clear_arg_list();
  static const int kArgListFieldNumber = 1;
  inline const ::gunir::compiler::RawExpressionList& arg_list() const;
  inline ::gunir::compiler::RawExpressionList* mutable_arg_list();
  inline ::gunir::compiler::RawExpressionList* release_arg_list();
  
  // required bool arg_is_star = 2;
  inline bool has_arg_is_star() const;
  inline void clear_arg_is_star();
  static const int kArgIsStarFieldNumber = 2;
  inline bool arg_is_star() const;
  inline void set_arg_is_star(bool value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawArguments)
 private:
  inline void set_has_arg_list();
  inline void clear_has_arg_list();
  inline void set_has_arg_is_star();
  inline void clear_has_arg_is_star();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawExpressionList* arg_list_;
  bool arg_is_star_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawArguments* default_instance_;
};
// -------------------------------------------------------------------

class RawFunction : public ::google::protobuf::Message {
 public:
  RawFunction();
  virtual ~RawFunction();
  
  RawFunction(const RawFunction& from);
  
  inline RawFunction& operator=(const RawFunction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawFunction& default_instance();
  
  void Swap(RawFunction* other);
  
  // implements Message ----------------------------------------------
  
  RawFunction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawFunction& from);
  void MergeFrom(const RawFunction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.StringMessage function_name = 1;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& function_name() const;
  inline ::gunir::compiler::StringMessage* mutable_function_name();
  inline ::gunir::compiler::StringMessage* release_function_name();
  
  // required .gunir.compiler.RawArguments args = 2;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::gunir::compiler::RawArguments& args() const;
  inline ::gunir::compiler::RawArguments* mutable_args();
  inline ::gunir::compiler::RawArguments* release_args();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawFunction)
 private:
  inline void set_has_function_name();
  inline void clear_has_function_name();
  inline void set_has_args();
  inline void clear_has_args();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* function_name_;
  ::gunir::compiler::RawArguments* args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawFunction* default_instance_;
};
// -------------------------------------------------------------------

class RawJoin : public ::google::protobuf::Message {
 public:
  RawJoin();
  virtual ~RawJoin();
  
  RawJoin(const RawJoin& from);
  
  inline RawJoin& operator=(const RawJoin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawJoin& default_instance();
  
  void Swap(RawJoin* other);
  
  // implements Message ----------------------------------------------
  
  RawJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawJoin& from);
  void MergeFrom(const RawJoin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.RawTable partner = 1;
  inline bool has_partner() const;
  inline void clear_partner();
  static const int kPartnerFieldNumber = 1;
  inline const ::gunir::compiler::RawTable& partner() const;
  inline ::gunir::compiler::RawTable* mutable_partner();
  inline ::gunir::compiler::RawTable* release_partner();
  
  // required .gunir.compiler.RawExpression expression = 2;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 2;
  inline const ::gunir::compiler::RawExpression& expression() const;
  inline ::gunir::compiler::RawExpression* mutable_expression();
  inline ::gunir::compiler::RawExpression* release_expression();
  
  // required .gunir.compiler.JoinOperator op = 3;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 3;
  inline gunir::compiler::JoinOperator op() const;
  inline void set_op(gunir::compiler::JoinOperator value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawJoin)
 private:
  inline void set_has_partner();
  inline void clear_has_partner();
  inline void set_has_expression();
  inline void clear_has_expression();
  inline void set_has_op();
  inline void clear_has_op();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawTable* partner_;
  ::gunir::compiler::RawExpression* expression_;
  int op_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawJoin* default_instance_;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message {
 public:
  Limit();
  virtual ~Limit();
  
  Limit(const Limit& from);
  
  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();
  
  void Swap(Limit* other);
  
  // implements Message ----------------------------------------------
  
  Limit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);
  
  // required int32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.Limit)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_number();
  inline void clear_has_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static Limit* default_instance_;
};
// -------------------------------------------------------------------

class RawWithin : public ::google::protobuf::Message {
 public:
  RawWithin();
  virtual ~RawWithin();
  
  RawWithin(const RawWithin& from);
  
  inline RawWithin& operator=(const RawWithin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawWithin& default_instance();
  
  void Swap(RawWithin* other);
  
  // implements Message ----------------------------------------------
  
  RawWithin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawWithin& from);
  void MergeFrom(const RawWithin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool is_record = 1;
  inline bool has_is_record() const;
  inline void clear_is_record();
  static const int kIsRecordFieldNumber = 1;
  inline bool is_record() const;
  inline void set_is_record(bool value);
  
  // optional .gunir.compiler.ColumnPath column = 2;
  inline bool has_column() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::gunir::compiler::ColumnPath& column() const;
  inline ::gunir::compiler::ColumnPath* mutable_column();
  inline ::gunir::compiler::ColumnPath* release_column();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawWithin)
 private:
  inline void set_has_is_record();
  inline void clear_has_is_record();
  inline void set_has_column();
  inline void clear_has_column();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::ColumnPath* column_;
  bool is_record_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawWithin* default_instance_;
};
// -------------------------------------------------------------------

class RawTarget : public ::google::protobuf::Message {
 public:
  RawTarget();
  virtual ~RawTarget();
  
  RawTarget(const RawTarget& from);
  
  inline RawTarget& operator=(const RawTarget& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawTarget& default_instance();
  
  void Swap(RawTarget* other);
  
  // implements Message ----------------------------------------------
  
  RawTarget* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawTarget& from);
  void MergeFrom(const RawTarget& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.RawExpression expression = 1;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 1;
  inline const ::gunir::compiler::RawExpression& expression() const;
  inline ::gunir::compiler::RawExpression* mutable_expression();
  inline ::gunir::compiler::RawExpression* release_expression();
  
  // optional .gunir.compiler.RawWithin within = 2;
  inline bool has_within() const;
  inline void clear_within();
  static const int kWithinFieldNumber = 2;
  inline const ::gunir::compiler::RawWithin& within() const;
  inline ::gunir::compiler::RawWithin* mutable_within();
  inline ::gunir::compiler::RawWithin* release_within();
  
  // optional .gunir.compiler.StringMessage alias = 3;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 3;
  inline const ::gunir::compiler::StringMessage& alias() const;
  inline ::gunir::compiler::StringMessage* mutable_alias();
  inline ::gunir::compiler::StringMessage* release_alias();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawTarget)
 private:
  inline void set_has_expression();
  inline void clear_has_expression();
  inline void set_has_within();
  inline void clear_has_within();
  inline void set_has_alias();
  inline void clear_has_alias();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawExpression* expression_;
  ::gunir::compiler::RawWithin* within_;
  ::gunir::compiler::StringMessage* alias_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawTarget* default_instance_;
};
// -------------------------------------------------------------------

class RawTargetList : public ::google::protobuf::Message {
 public:
  RawTargetList();
  virtual ~RawTargetList();
  
  RawTargetList(const RawTargetList& from);
  
  inline RawTargetList& operator=(const RawTargetList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawTargetList& default_instance();
  
  void Swap(RawTargetList* other);
  
  // implements Message ----------------------------------------------
  
  RawTargetList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawTargetList& from);
  void MergeFrom(const RawTargetList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.RawTarget target_list = 1;
  inline int target_list_size() const;
  inline void clear_target_list();
  static const int kTargetListFieldNumber = 1;
  inline const ::gunir::compiler::RawTarget& target_list(int index) const;
  inline ::gunir::compiler::RawTarget* mutable_target_list(int index);
  inline ::gunir::compiler::RawTarget* add_target_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTarget >&
      target_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTarget >*
      mutable_target_list();
  
  // required bool target_is_star = 2;
  inline bool has_target_is_star() const;
  inline void clear_target_is_star();
  static const int kTargetIsStarFieldNumber = 2;
  inline bool target_is_star() const;
  inline void set_target_is_star(bool value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawTargetList)
 private:
  inline void set_has_target_is_star();
  inline void clear_has_target_is_star();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTarget > target_list_;
  bool target_is_star_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawTargetList* default_instance_;
};
// -------------------------------------------------------------------

class RawTable : public ::google::protobuf::Message {
 public:
  RawTable();
  virtual ~RawTable();
  
  RawTable(const RawTable& from);
  
  inline RawTable& operator=(const RawTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawTable& default_instance();
  
  void Swap(RawTable* other);
  
  // implements Message ----------------------------------------------
  
  RawTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawTable& from);
  void MergeFrom(const RawTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.StringMessage table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& table_name() const;
  inline ::gunir::compiler::StringMessage* mutable_table_name();
  inline ::gunir::compiler::StringMessage* release_table_name();
  
  // optional .gunir.compiler.SelectStmt select_stmt = 2;
  inline bool has_select_stmt() const;
  inline void clear_select_stmt();
  static const int kSelectStmtFieldNumber = 2;
  inline const ::gunir::compiler::SelectStmt& select_stmt() const;
  inline ::gunir::compiler::SelectStmt* mutable_select_stmt();
  inline ::gunir::compiler::SelectStmt* release_select_stmt();
  
  // optional .gunir.compiler.StringMessage alias = 9;
  inline bool has_alias() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 9;
  inline const ::gunir::compiler::StringMessage& alias() const;
  inline ::gunir::compiler::StringMessage* mutable_alias();
  inline ::gunir::compiler::StringMessage* release_alias();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawTable)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_select_stmt();
  inline void clear_has_select_stmt();
  inline void set_has_alias();
  inline void clear_has_alias();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* table_name_;
  ::gunir::compiler::SelectStmt* select_stmt_;
  ::gunir::compiler::StringMessage* alias_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawTable* default_instance_;
};
// -------------------------------------------------------------------

class RawTableList : public ::google::protobuf::Message {
 public:
  RawTableList();
  virtual ~RawTableList();
  
  RawTableList(const RawTableList& from);
  
  inline RawTableList& operator=(const RawTableList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawTableList& default_instance();
  
  void Swap(RawTableList* other);
  
  // implements Message ----------------------------------------------
  
  RawTableList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RawTableList& from);
  void MergeFrom(const RawTableList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .gunir.compiler.RawTable table_list = 1;
  inline int table_list_size() const;
  inline void clear_table_list();
  static const int kTableListFieldNumber = 1;
  inline const ::gunir::compiler::RawTable& table_list(int index) const;
  inline ::gunir::compiler::RawTable* mutable_table_list(int index);
  inline ::gunir::compiler::RawTable* add_table_list();
  inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTable >&
      table_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTable >*
      mutable_table_list();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.RawTableList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTable > table_list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static RawTableList* default_instance_;
};
// -------------------------------------------------------------------

class SelectStmt : public ::google::protobuf::Message {
 public:
  SelectStmt();
  virtual ~SelectStmt();
  
  SelectStmt(const SelectStmt& from);
  
  inline SelectStmt& operator=(const SelectStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectStmt& default_instance();
  
  void Swap(SelectStmt* other);
  
  // implements Message ----------------------------------------------
  
  SelectStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SelectStmt& from);
  void MergeFrom(const SelectStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.RawTargetList target_list = 1;
  inline bool has_target_list() const;
  inline void clear_target_list();
  static const int kTargetListFieldNumber = 1;
  inline const ::gunir::compiler::RawTargetList& target_list() const;
  inline ::gunir::compiler::RawTargetList* mutable_target_list();
  inline ::gunir::compiler::RawTargetList* release_target_list();
  
  // required .gunir.compiler.RawTableList from_list = 2;
  inline bool has_from_list() const;
  inline void clear_from_list();
  static const int kFromListFieldNumber = 2;
  inline const ::gunir::compiler::RawTableList& from_list() const;
  inline ::gunir::compiler::RawTableList* mutable_from_list();
  inline ::gunir::compiler::RawTableList* release_from_list();
  
  // optional .gunir.compiler.RawExpression where_clause = 3;
  inline bool has_where_clause() const;
  inline void clear_where_clause();
  static const int kWhereClauseFieldNumber = 3;
  inline const ::gunir::compiler::RawExpression& where_clause() const;
  inline ::gunir::compiler::RawExpression* mutable_where_clause();
  inline ::gunir::compiler::RawExpression* release_where_clause();
  
  // optional .gunir.compiler.RawJoin join = 4;
  inline bool has_join() const;
  inline void clear_join();
  static const int kJoinFieldNumber = 4;
  inline const ::gunir::compiler::RawJoin& join() const;
  inline ::gunir::compiler::RawJoin* mutable_join();
  inline ::gunir::compiler::RawJoin* release_join();
  
  // optional .gunir.compiler.ColumnPathList groupby = 5;
  inline bool has_groupby() const;
  inline void clear_groupby();
  static const int kGroupbyFieldNumber = 5;
  inline const ::gunir::compiler::ColumnPathList& groupby() const;
  inline ::gunir::compiler::ColumnPathList* mutable_groupby();
  inline ::gunir::compiler::ColumnPathList* release_groupby();
  
  // optional .gunir.compiler.RawExpression having = 6;
  inline bool has_having() const;
  inline void clear_having();
  static const int kHavingFieldNumber = 6;
  inline const ::gunir::compiler::RawExpression& having() const;
  inline ::gunir::compiler::RawExpression* mutable_having();
  inline ::gunir::compiler::RawExpression* release_having();
  
  // optional .gunir.compiler.OrderColumnPathList orderby = 7;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 7;
  inline const ::gunir::compiler::OrderColumnPathList& orderby() const;
  inline ::gunir::compiler::OrderColumnPathList* mutable_orderby();
  inline ::gunir::compiler::OrderColumnPathList* release_orderby();
  
  // optional .gunir.compiler.Limit limit = 8;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 8;
  inline const ::gunir::compiler::Limit& limit() const;
  inline ::gunir::compiler::Limit* mutable_limit();
  inline ::gunir::compiler::Limit* release_limit();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.SelectStmt)
 private:
  inline void set_has_target_list();
  inline void clear_has_target_list();
  inline void set_has_from_list();
  inline void clear_has_from_list();
  inline void set_has_where_clause();
  inline void clear_has_where_clause();
  inline void set_has_join();
  inline void clear_has_join();
  inline void set_has_groupby();
  inline void clear_has_groupby();
  inline void set_has_having();
  inline void clear_has_having();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_limit();
  inline void clear_has_limit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::RawTargetList* target_list_;
  ::gunir::compiler::RawTableList* from_list_;
  ::gunir::compiler::RawExpression* where_clause_;
  ::gunir::compiler::RawJoin* join_;
  ::gunir::compiler::ColumnPathList* groupby_;
  ::gunir::compiler::RawExpression* having_;
  ::gunir::compiler::OrderColumnPathList* orderby_;
  ::gunir::compiler::Limit* limit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static SelectStmt* default_instance_;
};
// -------------------------------------------------------------------

class CreateTableStmt : public ::google::protobuf::Message {
 public:
  CreateTableStmt();
  virtual ~CreateTableStmt();
  
  CreateTableStmt(const CreateTableStmt& from);
  
  inline CreateTableStmt& operator=(const CreateTableStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTableStmt& default_instance();
  
  void Swap(CreateTableStmt* other);
  
  // implements Message ----------------------------------------------
  
  CreateTableStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateTableStmt& from);
  void MergeFrom(const CreateTableStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.StringMessage table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& table_name() const;
  inline ::gunir::compiler::StringMessage* mutable_table_name();
  inline ::gunir::compiler::StringMessage* release_table_name();
  
  // required .gunir.compiler.StringMessage input_path = 2;
  inline bool has_input_path() const;
  inline void clear_input_path();
  static const int kInputPathFieldNumber = 2;
  inline const ::gunir::compiler::StringMessage& input_path() const;
  inline ::gunir::compiler::StringMessage* mutable_input_path();
  inline ::gunir::compiler::StringMessage* release_input_path();
  
  // required .gunir.compiler.StringMessage table_schema = 3;
  inline bool has_table_schema() const;
  inline void clear_table_schema();
  static const int kTableSchemaFieldNumber = 3;
  inline const ::gunir::compiler::StringMessage& table_schema() const;
  inline ::gunir::compiler::StringMessage* mutable_table_schema();
  inline ::gunir::compiler::StringMessage* release_table_schema();
  
  // required .gunir.compiler.StringMessage message_name = 4;
  inline bool has_message_name() const;
  inline void clear_message_name();
  static const int kMessageNameFieldNumber = 4;
  inline const ::gunir::compiler::StringMessage& message_name() const;
  inline ::gunir::compiler::StringMessage* mutable_message_name();
  inline ::gunir::compiler::StringMessage* release_message_name();
  
  // optional .gunir.compiler.StringMessage charset_encoding = 5;
  inline bool has_charset_encoding() const;
  inline void clear_charset_encoding();
  static const int kCharsetEncodingFieldNumber = 5;
  inline const ::gunir::compiler::StringMessage& charset_encoding() const;
  inline ::gunir::compiler::StringMessage* mutable_charset_encoding();
  inline ::gunir::compiler::StringMessage* release_charset_encoding();
  
  // optional .gunir.compiler.StringMessage table_type = 6;
  inline bool has_table_type() const;
  inline void clear_table_type();
  static const int kTableTypeFieldNumber = 6;
  inline const ::gunir::compiler::StringMessage& table_type() const;
  inline ::gunir::compiler::StringMessage* mutable_table_type();
  inline ::gunir::compiler::StringMessage* release_table_type();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.CreateTableStmt)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_input_path();
  inline void clear_has_input_path();
  inline void set_has_table_schema();
  inline void clear_has_table_schema();
  inline void set_has_message_name();
  inline void clear_has_message_name();
  inline void set_has_charset_encoding();
  inline void clear_has_charset_encoding();
  inline void set_has_table_type();
  inline void clear_has_table_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* table_name_;
  ::gunir::compiler::StringMessage* input_path_;
  ::gunir::compiler::StringMessage* table_schema_;
  ::gunir::compiler::StringMessage* message_name_;
  ::gunir::compiler::StringMessage* charset_encoding_;
  ::gunir::compiler::StringMessage* table_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static CreateTableStmt* default_instance_;
};
// -------------------------------------------------------------------

class DefineTableStmt : public ::google::protobuf::Message {
 public:
  DefineTableStmt();
  virtual ~DefineTableStmt();
  
  DefineTableStmt(const DefineTableStmt& from);
  
  inline DefineTableStmt& operator=(const DefineTableStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DefineTableStmt& default_instance();
  
  void Swap(DefineTableStmt* other);
  
  // implements Message ----------------------------------------------
  
  DefineTableStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DefineTableStmt& from);
  void MergeFrom(const DefineTableStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.StringMessage table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& table_name() const;
  inline ::gunir::compiler::StringMessage* mutable_table_name();
  inline ::gunir::compiler::StringMessage* release_table_name();
  
  // required .gunir.compiler.StringMessage input_path = 2;
  inline bool has_input_path() const;
  inline void clear_input_path();
  static const int kInputPathFieldNumber = 2;
  inline const ::gunir::compiler::StringMessage& input_path() const;
  inline ::gunir::compiler::StringMessage* mutable_input_path();
  inline ::gunir::compiler::StringMessage* release_input_path();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.DefineTableStmt)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  inline void set_has_input_path();
  inline void clear_has_input_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* table_name_;
  ::gunir::compiler::StringMessage* input_path_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static DefineTableStmt* default_instance_;
};
// -------------------------------------------------------------------

class DropTableStmt : public ::google::protobuf::Message {
 public:
  DropTableStmt();
  virtual ~DropTableStmt();
  
  DropTableStmt(const DropTableStmt& from);
  
  inline DropTableStmt& operator=(const DropTableStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DropTableStmt& default_instance();
  
  void Swap(DropTableStmt* other);
  
  // implements Message ----------------------------------------------
  
  DropTableStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DropTableStmt& from);
  void MergeFrom(const DropTableStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .gunir.compiler.StringMessage table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& table_name() const;
  inline ::gunir::compiler::StringMessage* mutable_table_name();
  inline ::gunir::compiler::StringMessage* release_table_name();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.DropTableStmt)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* table_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static DropTableStmt* default_instance_;
};
// -------------------------------------------------------------------

class ShowStmt : public ::google::protobuf::Message {
 public:
  ShowStmt();
  virtual ~ShowStmt();
  
  ShowStmt(const ShowStmt& from);
  
  inline ShowStmt& operator=(const ShowStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowStmt& default_instance();
  
  void Swap(ShowStmt* other);
  
  // implements Message ----------------------------------------------
  
  ShowStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShowStmt& from);
  void MergeFrom(const ShowStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.StringMessage table_name = 1;
  inline bool has_table_name() const;
  inline void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& table_name() const;
  inline ::gunir::compiler::StringMessage* mutable_table_name();
  inline ::gunir::compiler::StringMessage* release_table_name();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.ShowStmt)
 private:
  inline void set_has_table_name();
  inline void clear_has_table_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* table_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static ShowStmt* default_instance_;
};
// -------------------------------------------------------------------

class HelpStmt : public ::google::protobuf::Message {
 public:
  HelpStmt();
  virtual ~HelpStmt();
  
  HelpStmt(const HelpStmt& from);
  
  inline HelpStmt& operator=(const HelpStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HelpStmt& default_instance();
  
  void Swap(HelpStmt* other);
  
  // implements Message ----------------------------------------------
  
  HelpStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelpStmt& from);
  void MergeFrom(const HelpStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  inline bool has_cmd_name() const;
  inline void clear_cmd_name();
  static const int kCmdNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& cmd_name() const;
  inline ::gunir::compiler::StringMessage* mutable_cmd_name();
  inline ::gunir::compiler::StringMessage* release_cmd_name();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.HelpStmt)
 private:
  inline void set_has_cmd_name();
  inline void clear_has_cmd_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* cmd_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static HelpStmt* default_instance_;
};
// -------------------------------------------------------------------

class QuitStmt : public ::google::protobuf::Message {
 public:
  QuitStmt();
  virtual ~QuitStmt();
  
  QuitStmt(const QuitStmt& from);
  
  inline QuitStmt& operator=(const QuitStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QuitStmt& default_instance();
  
  void Swap(QuitStmt* other);
  
  // implements Message ----------------------------------------------
  
  QuitStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuitStmt& from);
  void MergeFrom(const QuitStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.StringMessage cmd_name = 1;
  inline bool has_cmd_name() const;
  inline void clear_cmd_name();
  static const int kCmdNameFieldNumber = 1;
  inline const ::gunir::compiler::StringMessage& cmd_name() const;
  inline ::gunir::compiler::StringMessage* mutable_cmd_name();
  inline ::gunir::compiler::StringMessage* release_cmd_name();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.QuitStmt)
 private:
  inline void set_has_cmd_name();
  inline void clear_has_cmd_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::StringMessage* cmd_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static QuitStmt* default_instance_;
};
// -------------------------------------------------------------------

class HistoryStmt : public ::google::protobuf::Message {
 public:
  HistoryStmt();
  virtual ~HistoryStmt();
  
  HistoryStmt(const HistoryStmt& from);
  
  inline HistoryStmt& operator=(const HistoryStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryStmt& default_instance();
  
  void Swap(HistoryStmt* other);
  
  // implements Message ----------------------------------------------
  
  HistoryStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryStmt& from);
  void MergeFrom(const HistoryStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);
  
  // optional int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.HistoryStmt)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static HistoryStmt* default_instance_;
};
// -------------------------------------------------------------------

class QueryStmt : public ::google::protobuf::Message {
 public:
  QueryStmt();
  virtual ~QueryStmt();
  
  QueryStmt(const QueryStmt& from);
  
  inline QueryStmt& operator=(const QueryStmt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryStmt& default_instance();
  
  void Swap(QueryStmt* other);
  
  // implements Message ----------------------------------------------
  
  QueryStmt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryStmt& from);
  void MergeFrom(const QueryStmt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .gunir.compiler.SelectStmt select = 1;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 1;
  inline const ::gunir::compiler::SelectStmt& select() const;
  inline ::gunir::compiler::SelectStmt* mutable_select();
  inline ::gunir::compiler::SelectStmt* release_select();
  
  // optional .gunir.compiler.CreateTableStmt create = 2;
  inline bool has_create() const;
  inline void clear_create();
  static const int kCreateFieldNumber = 2;
  inline const ::gunir::compiler::CreateTableStmt& create() const;
  inline ::gunir::compiler::CreateTableStmt* mutable_create();
  inline ::gunir::compiler::CreateTableStmt* release_create();
  
  // optional .gunir.compiler.DropTableStmt drop = 3;
  inline bool has_drop() const;
  inline void clear_drop();
  static const int kDropFieldNumber = 3;
  inline const ::gunir::compiler::DropTableStmt& drop() const;
  inline ::gunir::compiler::DropTableStmt* mutable_drop();
  inline ::gunir::compiler::DropTableStmt* release_drop();
  
  // optional .gunir.compiler.HelpStmt help = 4;
  inline bool has_help() const;
  inline void clear_help();
  static const int kHelpFieldNumber = 4;
  inline const ::gunir::compiler::HelpStmt& help() const;
  inline ::gunir::compiler::HelpStmt* mutable_help();
  inline ::gunir::compiler::HelpStmt* release_help();
  
  // optional .gunir.compiler.ShowStmt show = 5;
  inline bool has_show() const;
  inline void clear_show();
  static const int kShowFieldNumber = 5;
  inline const ::gunir::compiler::ShowStmt& show() const;
  inline ::gunir::compiler::ShowStmt* mutable_show();
  inline ::gunir::compiler::ShowStmt* release_show();
  
  // optional .gunir.compiler.HistoryStmt history = 6;
  inline bool has_history() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 6;
  inline const ::gunir::compiler::HistoryStmt& history() const;
  inline ::gunir::compiler::HistoryStmt* mutable_history();
  inline ::gunir::compiler::HistoryStmt* release_history();
  
  // optional .gunir.compiler.QuitStmt quit = 7;
  inline bool has_quit() const;
  inline void clear_quit();
  static const int kQuitFieldNumber = 7;
  inline const ::gunir::compiler::QuitStmt& quit() const;
  inline ::gunir::compiler::QuitStmt* mutable_quit();
  inline ::gunir::compiler::QuitStmt* release_quit();
  
  // optional .gunir.compiler.DefineTableStmt define = 8;
  inline bool has_define() const;
  inline void clear_define();
  static const int kDefineFieldNumber = 8;
  inline const ::gunir::compiler::DefineTableStmt& define() const;
  inline ::gunir::compiler::DefineTableStmt* mutable_define();
  inline ::gunir::compiler::DefineTableStmt* release_define();
  
  // @@protoc_insertion_point(class_scope:gunir.compiler.QueryStmt)
 private:
  inline void set_has_select();
  inline void clear_has_select();
  inline void set_has_create();
  inline void clear_has_create();
  inline void set_has_drop();
  inline void clear_has_drop();
  inline void set_has_help();
  inline void clear_has_help();
  inline void set_has_show();
  inline void clear_has_show();
  inline void set_has_history();
  inline void clear_has_history();
  inline void set_has_quit();
  inline void clear_has_quit();
  inline void set_has_define();
  inline void clear_has_define();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::gunir::compiler::SelectStmt* select_;
  ::gunir::compiler::CreateTableStmt* create_;
  ::gunir::compiler::DropTableStmt* drop_;
  ::gunir::compiler::HelpStmt* help_;
  ::gunir::compiler::ShowStmt* show_;
  ::gunir::compiler::HistoryStmt* history_;
  ::gunir::compiler::QuitStmt* quit_;
  ::gunir::compiler::DefineTableStmt* define_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_select_5fstmt_2eproto();
  friend void protobuf_AssignDesc_select_5fstmt_2eproto();
  friend void protobuf_ShutdownFile_select_5fstmt_2eproto();
  
  void InitAsDefaultInstance();
  static QueryStmt* default_instance_;
};
// ===================================================================


// ===================================================================

// StringMessage

// required string char_string = 1;
inline bool StringMessage::has_char_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringMessage::set_has_char_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringMessage::clear_has_char_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringMessage::clear_char_string() {
  if (char_string_ != &::google::protobuf::internal::kEmptyString) {
    char_string_->clear();
  }
  clear_has_char_string();
}
inline const ::std::string& StringMessage::char_string() const {
  return *char_string_;
}
inline void StringMessage::set_char_string(const ::std::string& value) {
  set_has_char_string();
  if (char_string_ == &::google::protobuf::internal::kEmptyString) {
    char_string_ = new ::std::string;
  }
  char_string_->assign(value);
}
inline void StringMessage::set_char_string(const char* value) {
  set_has_char_string();
  if (char_string_ == &::google::protobuf::internal::kEmptyString) {
    char_string_ = new ::std::string;
  }
  char_string_->assign(value);
}
inline void StringMessage::set_char_string(const char* value, size_t size) {
  set_has_char_string();
  if (char_string_ == &::google::protobuf::internal::kEmptyString) {
    char_string_ = new ::std::string;
  }
  char_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringMessage::mutable_char_string() {
  set_has_char_string();
  if (char_string_ == &::google::protobuf::internal::kEmptyString) {
    char_string_ = new ::std::string;
  }
  return char_string_;
}
inline ::std::string* StringMessage::release_char_string() {
  clear_has_char_string();
  if (char_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = char_string_;
    char_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ColumnPath

// repeated .gunir.compiler.StringMessage field_list = 1;
inline int ColumnPath::field_list_size() const {
  return field_list_.size();
}
inline void ColumnPath::clear_field_list() {
  field_list_.Clear();
}
inline const ::gunir::compiler::StringMessage& ColumnPath::field_list(int index) const {
  return field_list_.Get(index);
}
inline ::gunir::compiler::StringMessage* ColumnPath::mutable_field_list(int index) {
  return field_list_.Mutable(index);
}
inline ::gunir::compiler::StringMessage* ColumnPath::add_field_list() {
  return field_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::StringMessage >&
ColumnPath::field_list() const {
  return field_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::StringMessage >*
ColumnPath::mutable_field_list() {
  return &field_list_;
}

// optional bool has_distinct = 2;
inline bool ColumnPath::has_has_distinct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnPath::set_has_has_distinct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnPath::clear_has_has_distinct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnPath::clear_has_distinct() {
  has_distinct_ = false;
  clear_has_has_distinct();
}
inline bool ColumnPath::has_distinct() const {
  return has_distinct_;
}
inline void ColumnPath::set_has_distinct(bool value) {
  set_has_has_distinct();
  has_distinct_ = value;
}

// -------------------------------------------------------------------

// ColumnPathList

// repeated .gunir.compiler.ColumnPath path_list = 1;
inline int ColumnPathList::path_list_size() const {
  return path_list_.size();
}
inline void ColumnPathList::clear_path_list() {
  path_list_.Clear();
}
inline const ::gunir::compiler::ColumnPath& ColumnPathList::path_list(int index) const {
  return path_list_.Get(index);
}
inline ::gunir::compiler::ColumnPath* ColumnPathList::mutable_path_list(int index) {
  return path_list_.Mutable(index);
}
inline ::gunir::compiler::ColumnPath* ColumnPathList::add_path_list() {
  return path_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::ColumnPath >&
ColumnPathList::path_list() const {
  return path_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::ColumnPath >*
ColumnPathList::mutable_path_list() {
  return &path_list_;
}

// -------------------------------------------------------------------

// OrderColumnPath

// required .gunir.compiler.ColumnPath path = 1;
inline bool OrderColumnPath::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderColumnPath::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderColumnPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderColumnPath::clear_path() {
  if (path_ != NULL) path_->::gunir::compiler::ColumnPath::Clear();
  clear_has_path();
}
inline const ::gunir::compiler::ColumnPath& OrderColumnPath::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::gunir::compiler::ColumnPath* OrderColumnPath::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::gunir::compiler::ColumnPath;
  return path_;
}
inline ::gunir::compiler::ColumnPath* OrderColumnPath::release_path() {
  clear_has_path();
  ::gunir::compiler::ColumnPath* temp = path_;
  path_ = NULL;
  return temp;
}

// required .gunir.compiler.OrderType type = 2;
inline bool OrderColumnPath::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderColumnPath::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderColumnPath::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderColumnPath::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline gunir::compiler::OrderType OrderColumnPath::type() const {
  return static_cast< gunir::compiler::OrderType >(type_);
}
inline void OrderColumnPath::set_type(gunir::compiler::OrderType value) {
  GOOGLE_DCHECK(gunir::compiler::OrderType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// OrderColumnPathList

// repeated .gunir.compiler.OrderColumnPath path_list = 1;
inline int OrderColumnPathList::path_list_size() const {
  return path_list_.size();
}
inline void OrderColumnPathList::clear_path_list() {
  path_list_.Clear();
}
inline const ::gunir::compiler::OrderColumnPath& OrderColumnPathList::path_list(int index) const {
  return path_list_.Get(index);
}
inline ::gunir::compiler::OrderColumnPath* OrderColumnPathList::mutable_path_list(int index) {
  return path_list_.Mutable(index);
}
inline ::gunir::compiler::OrderColumnPath* OrderColumnPathList::add_path_list() {
  return path_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::OrderColumnPath >&
OrderColumnPathList::path_list() const {
  return path_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::OrderColumnPath >*
OrderColumnPathList::mutable_path_list() {
  return &path_list_;
}

// -------------------------------------------------------------------

// RawAtomicExpression

// optional .gunir.compiler.RawFunction function = 1;
inline bool RawAtomicExpression::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawAtomicExpression::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawAtomicExpression::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawAtomicExpression::clear_function() {
  if (function_ != NULL) function_->::gunir::compiler::RawFunction::Clear();
  clear_has_function();
}
inline const ::gunir::compiler::RawFunction& RawAtomicExpression::function() const {
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::gunir::compiler::RawFunction* RawAtomicExpression::mutable_function() {
  set_has_function();
  if (function_ == NULL) function_ = new ::gunir::compiler::RawFunction;
  return function_;
}
inline ::gunir::compiler::RawFunction* RawAtomicExpression::release_function() {
  clear_has_function();
  ::gunir::compiler::RawFunction* temp = function_;
  function_ = NULL;
  return temp;
}

// optional int64 integer = 2;
inline bool RawAtomicExpression::has_integer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawAtomicExpression::set_has_integer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawAtomicExpression::clear_has_integer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawAtomicExpression::clear_integer() {
  integer_ = GOOGLE_LONGLONG(0);
  clear_has_integer();
}
inline ::google::protobuf::int64 RawAtomicExpression::integer() const {
  return integer_;
}
inline void RawAtomicExpression::set_integer(::google::protobuf::int64 value) {
  set_has_integer();
  integer_ = value;
}

// optional double floating = 3;
inline bool RawAtomicExpression::has_floating() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawAtomicExpression::set_has_floating() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawAtomicExpression::clear_has_floating() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawAtomicExpression::clear_floating() {
  floating_ = 0;
  clear_has_floating();
}
inline double RawAtomicExpression::floating() const {
  return floating_;
}
inline void RawAtomicExpression::set_floating(double value) {
  set_has_floating();
  floating_ = value;
}

// optional bool boolean = 4;
inline bool RawAtomicExpression::has_boolean() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RawAtomicExpression::set_has_boolean() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RawAtomicExpression::clear_has_boolean() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RawAtomicExpression::clear_boolean() {
  boolean_ = false;
  clear_has_boolean();
}
inline bool RawAtomicExpression::boolean() const {
  return boolean_;
}
inline void RawAtomicExpression::set_boolean(bool value) {
  set_has_boolean();
  boolean_ = value;
}

// optional .gunir.compiler.StringMessage char_string = 5;
inline bool RawAtomicExpression::has_char_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RawAtomicExpression::set_has_char_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RawAtomicExpression::clear_has_char_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RawAtomicExpression::clear_char_string() {
  if (char_string_ != NULL) char_string_->::gunir::compiler::StringMessage::Clear();
  clear_has_char_string();
}
inline const ::gunir::compiler::StringMessage& RawAtomicExpression::char_string() const {
  return char_string_ != NULL ? *char_string_ : *default_instance_->char_string_;
}
inline ::gunir::compiler::StringMessage* RawAtomicExpression::mutable_char_string() {
  set_has_char_string();
  if (char_string_ == NULL) char_string_ = new ::gunir::compiler::StringMessage;
  return char_string_;
}
inline ::gunir::compiler::StringMessage* RawAtomicExpression::release_char_string() {
  clear_has_char_string();
  ::gunir::compiler::StringMessage* temp = char_string_;
  char_string_ = NULL;
  return temp;
}

// optional .gunir.compiler.ColumnPath column = 6;
inline bool RawAtomicExpression::has_column() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RawAtomicExpression::set_has_column() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RawAtomicExpression::clear_has_column() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RawAtomicExpression::clear_column() {
  if (column_ != NULL) column_->::gunir::compiler::ColumnPath::Clear();
  clear_has_column();
}
inline const ::gunir::compiler::ColumnPath& RawAtomicExpression::column() const {
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::gunir::compiler::ColumnPath* RawAtomicExpression::mutable_column() {
  set_has_column();
  if (column_ == NULL) column_ = new ::gunir::compiler::ColumnPath;
  return column_;
}
inline ::gunir::compiler::ColumnPath* RawAtomicExpression::release_column() {
  clear_has_column();
  ::gunir::compiler::ColumnPath* temp = column_;
  column_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawExpression expression = 7;
inline bool RawAtomicExpression::has_expression() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RawAtomicExpression::set_has_expression() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RawAtomicExpression::clear_has_expression() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RawAtomicExpression::clear_expression() {
  if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
  clear_has_expression();
}
inline const ::gunir::compiler::RawExpression& RawAtomicExpression::expression() const {
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::gunir::compiler::RawExpression* RawAtomicExpression::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) expression_ = new ::gunir::compiler::RawExpression;
  return expression_;
}
inline ::gunir::compiler::RawExpression* RawAtomicExpression::release_expression() {
  clear_has_expression();
  ::gunir::compiler::RawExpression* temp = expression_;
  expression_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RawExpression

// optional .gunir.compiler.RawExpression left = 1;
inline bool RawExpression::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawExpression::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawExpression::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawExpression::clear_left() {
  if (left_ != NULL) left_->::gunir::compiler::RawExpression::Clear();
  clear_has_left();
}
inline const ::gunir::compiler::RawExpression& RawExpression::left() const {
  return left_ != NULL ? *left_ : *default_instance_->left_;
}
inline ::gunir::compiler::RawExpression* RawExpression::mutable_left() {
  set_has_left();
  if (left_ == NULL) left_ = new ::gunir::compiler::RawExpression;
  return left_;
}
inline ::gunir::compiler::RawExpression* RawExpression::release_left() {
  clear_has_left();
  ::gunir::compiler::RawExpression* temp = left_;
  left_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawExpression right = 2;
inline bool RawExpression::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawExpression::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawExpression::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawExpression::clear_right() {
  if (right_ != NULL) right_->::gunir::compiler::RawExpression::Clear();
  clear_has_right();
}
inline const ::gunir::compiler::RawExpression& RawExpression::right() const {
  return right_ != NULL ? *right_ : *default_instance_->right_;
}
inline ::gunir::compiler::RawExpression* RawExpression::mutable_right() {
  set_has_right();
  if (right_ == NULL) right_ = new ::gunir::compiler::RawExpression;
  return right_;
}
inline ::gunir::compiler::RawExpression* RawExpression::release_right() {
  clear_has_right();
  ::gunir::compiler::RawExpression* temp = right_;
  right_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawAtomicExpression atomic = 3;
inline bool RawExpression::has_atomic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawExpression::set_has_atomic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawExpression::clear_has_atomic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawExpression::clear_atomic() {
  if (atomic_ != NULL) atomic_->::gunir::compiler::RawAtomicExpression::Clear();
  clear_has_atomic();
}
inline const ::gunir::compiler::RawAtomicExpression& RawExpression::atomic() const {
  return atomic_ != NULL ? *atomic_ : *default_instance_->atomic_;
}
inline ::gunir::compiler::RawAtomicExpression* RawExpression::mutable_atomic() {
  set_has_atomic();
  if (atomic_ == NULL) atomic_ = new ::gunir::compiler::RawAtomicExpression;
  return atomic_;
}
inline ::gunir::compiler::RawAtomicExpression* RawExpression::release_atomic() {
  clear_has_atomic();
  ::gunir::compiler::RawAtomicExpression* temp = atomic_;
  atomic_ = NULL;
  return temp;
}

// optional .gunir.compiler.Operators op = 4;
inline bool RawExpression::has_op() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RawExpression::set_has_op() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RawExpression::clear_has_op() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RawExpression::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline gunir::compiler::Operators RawExpression::op() const {
  return static_cast< gunir::compiler::Operators >(op_);
}
inline void RawExpression::set_op(gunir::compiler::Operators value) {
  GOOGLE_DCHECK(gunir::compiler::Operators_IsValid(value));
  set_has_op();
  op_ = value;
}

// -------------------------------------------------------------------

// RawExpressionList

// repeated .gunir.compiler.RawExpression expr_list = 1;
inline int RawExpressionList::expr_list_size() const {
  return expr_list_.size();
}
inline void RawExpressionList::clear_expr_list() {
  expr_list_.Clear();
}
inline const ::gunir::compiler::RawExpression& RawExpressionList::expr_list(int index) const {
  return expr_list_.Get(index);
}
inline ::gunir::compiler::RawExpression* RawExpressionList::mutable_expr_list(int index) {
  return expr_list_.Mutable(index);
}
inline ::gunir::compiler::RawExpression* RawExpressionList::add_expr_list() {
  return expr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawExpression >&
RawExpressionList::expr_list() const {
  return expr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawExpression >*
RawExpressionList::mutable_expr_list() {
  return &expr_list_;
}

// -------------------------------------------------------------------

// RawArguments

// optional .gunir.compiler.RawExpressionList arg_list = 1;
inline bool RawArguments::has_arg_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawArguments::set_has_arg_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawArguments::clear_has_arg_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawArguments::clear_arg_list() {
  if (arg_list_ != NULL) arg_list_->::gunir::compiler::RawExpressionList::Clear();
  clear_has_arg_list();
}
inline const ::gunir::compiler::RawExpressionList& RawArguments::arg_list() const {
  return arg_list_ != NULL ? *arg_list_ : *default_instance_->arg_list_;
}
inline ::gunir::compiler::RawExpressionList* RawArguments::mutable_arg_list() {
  set_has_arg_list();
  if (arg_list_ == NULL) arg_list_ = new ::gunir::compiler::RawExpressionList;
  return arg_list_;
}
inline ::gunir::compiler::RawExpressionList* RawArguments::release_arg_list() {
  clear_has_arg_list();
  ::gunir::compiler::RawExpressionList* temp = arg_list_;
  arg_list_ = NULL;
  return temp;
}

// required bool arg_is_star = 2;
inline bool RawArguments::has_arg_is_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawArguments::set_has_arg_is_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawArguments::clear_has_arg_is_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawArguments::clear_arg_is_star() {
  arg_is_star_ = false;
  clear_has_arg_is_star();
}
inline bool RawArguments::arg_is_star() const {
  return arg_is_star_;
}
inline void RawArguments::set_arg_is_star(bool value) {
  set_has_arg_is_star();
  arg_is_star_ = value;
}

// -------------------------------------------------------------------

// RawFunction

// required .gunir.compiler.StringMessage function_name = 1;
inline bool RawFunction::has_function_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawFunction::set_has_function_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawFunction::clear_has_function_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawFunction::clear_function_name() {
  if (function_name_ != NULL) function_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_function_name();
}
inline const ::gunir::compiler::StringMessage& RawFunction::function_name() const {
  return function_name_ != NULL ? *function_name_ : *default_instance_->function_name_;
}
inline ::gunir::compiler::StringMessage* RawFunction::mutable_function_name() {
  set_has_function_name();
  if (function_name_ == NULL) function_name_ = new ::gunir::compiler::StringMessage;
  return function_name_;
}
inline ::gunir::compiler::StringMessage* RawFunction::release_function_name() {
  clear_has_function_name();
  ::gunir::compiler::StringMessage* temp = function_name_;
  function_name_ = NULL;
  return temp;
}

// required .gunir.compiler.RawArguments args = 2;
inline bool RawFunction::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawFunction::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawFunction::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawFunction::clear_args() {
  if (args_ != NULL) args_->::gunir::compiler::RawArguments::Clear();
  clear_has_args();
}
inline const ::gunir::compiler::RawArguments& RawFunction::args() const {
  return args_ != NULL ? *args_ : *default_instance_->args_;
}
inline ::gunir::compiler::RawArguments* RawFunction::mutable_args() {
  set_has_args();
  if (args_ == NULL) args_ = new ::gunir::compiler::RawArguments;
  return args_;
}
inline ::gunir::compiler::RawArguments* RawFunction::release_args() {
  clear_has_args();
  ::gunir::compiler::RawArguments* temp = args_;
  args_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RawJoin

// required .gunir.compiler.RawTable partner = 1;
inline bool RawJoin::has_partner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawJoin::set_has_partner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawJoin::clear_has_partner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawJoin::clear_partner() {
  if (partner_ != NULL) partner_->::gunir::compiler::RawTable::Clear();
  clear_has_partner();
}
inline const ::gunir::compiler::RawTable& RawJoin::partner() const {
  return partner_ != NULL ? *partner_ : *default_instance_->partner_;
}
inline ::gunir::compiler::RawTable* RawJoin::mutable_partner() {
  set_has_partner();
  if (partner_ == NULL) partner_ = new ::gunir::compiler::RawTable;
  return partner_;
}
inline ::gunir::compiler::RawTable* RawJoin::release_partner() {
  clear_has_partner();
  ::gunir::compiler::RawTable* temp = partner_;
  partner_ = NULL;
  return temp;
}

// required .gunir.compiler.RawExpression expression = 2;
inline bool RawJoin::has_expression() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawJoin::set_has_expression() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawJoin::clear_has_expression() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawJoin::clear_expression() {
  if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
  clear_has_expression();
}
inline const ::gunir::compiler::RawExpression& RawJoin::expression() const {
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::gunir::compiler::RawExpression* RawJoin::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) expression_ = new ::gunir::compiler::RawExpression;
  return expression_;
}
inline ::gunir::compiler::RawExpression* RawJoin::release_expression() {
  clear_has_expression();
  ::gunir::compiler::RawExpression* temp = expression_;
  expression_ = NULL;
  return temp;
}

// required .gunir.compiler.JoinOperator op = 3;
inline bool RawJoin::has_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawJoin::set_has_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawJoin::clear_has_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawJoin::clear_op() {
  op_ = 1;
  clear_has_op();
}
inline gunir::compiler::JoinOperator RawJoin::op() const {
  return static_cast< gunir::compiler::JoinOperator >(op_);
}
inline void RawJoin::set_op(gunir::compiler::JoinOperator value) {
  GOOGLE_DCHECK(gunir::compiler::JoinOperator_IsValid(value));
  set_has_op();
  op_ = value;
}

// -------------------------------------------------------------------

// Limit

// optional int32 start = 1;
inline bool Limit::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 Limit::start() const {
  return start_;
}
inline void Limit::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// required int32 number = 2;
inline bool Limit::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Limit::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Limit::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Limit::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Limit::number() const {
  return number_;
}
inline void Limit::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// RawWithin

// required bool is_record = 1;
inline bool RawWithin::has_is_record() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawWithin::set_has_is_record() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawWithin::clear_has_is_record() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawWithin::clear_is_record() {
  is_record_ = false;
  clear_has_is_record();
}
inline bool RawWithin::is_record() const {
  return is_record_;
}
inline void RawWithin::set_is_record(bool value) {
  set_has_is_record();
  is_record_ = value;
}

// optional .gunir.compiler.ColumnPath column = 2;
inline bool RawWithin::has_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawWithin::set_has_column() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawWithin::clear_has_column() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawWithin::clear_column() {
  if (column_ != NULL) column_->::gunir::compiler::ColumnPath::Clear();
  clear_has_column();
}
inline const ::gunir::compiler::ColumnPath& RawWithin::column() const {
  return column_ != NULL ? *column_ : *default_instance_->column_;
}
inline ::gunir::compiler::ColumnPath* RawWithin::mutable_column() {
  set_has_column();
  if (column_ == NULL) column_ = new ::gunir::compiler::ColumnPath;
  return column_;
}
inline ::gunir::compiler::ColumnPath* RawWithin::release_column() {
  clear_has_column();
  ::gunir::compiler::ColumnPath* temp = column_;
  column_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RawTarget

// required .gunir.compiler.RawExpression expression = 1;
inline bool RawTarget::has_expression() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawTarget::set_has_expression() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawTarget::clear_has_expression() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawTarget::clear_expression() {
  if (expression_ != NULL) expression_->::gunir::compiler::RawExpression::Clear();
  clear_has_expression();
}
inline const ::gunir::compiler::RawExpression& RawTarget::expression() const {
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::gunir::compiler::RawExpression* RawTarget::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) expression_ = new ::gunir::compiler::RawExpression;
  return expression_;
}
inline ::gunir::compiler::RawExpression* RawTarget::release_expression() {
  clear_has_expression();
  ::gunir::compiler::RawExpression* temp = expression_;
  expression_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawWithin within = 2;
inline bool RawTarget::has_within() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawTarget::set_has_within() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawTarget::clear_has_within() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawTarget::clear_within() {
  if (within_ != NULL) within_->::gunir::compiler::RawWithin::Clear();
  clear_has_within();
}
inline const ::gunir::compiler::RawWithin& RawTarget::within() const {
  return within_ != NULL ? *within_ : *default_instance_->within_;
}
inline ::gunir::compiler::RawWithin* RawTarget::mutable_within() {
  set_has_within();
  if (within_ == NULL) within_ = new ::gunir::compiler::RawWithin;
  return within_;
}
inline ::gunir::compiler::RawWithin* RawTarget::release_within() {
  clear_has_within();
  ::gunir::compiler::RawWithin* temp = within_;
  within_ = NULL;
  return temp;
}

// optional .gunir.compiler.StringMessage alias = 3;
inline bool RawTarget::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawTarget::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawTarget::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawTarget::clear_alias() {
  if (alias_ != NULL) alias_->::gunir::compiler::StringMessage::Clear();
  clear_has_alias();
}
inline const ::gunir::compiler::StringMessage& RawTarget::alias() const {
  return alias_ != NULL ? *alias_ : *default_instance_->alias_;
}
inline ::gunir::compiler::StringMessage* RawTarget::mutable_alias() {
  set_has_alias();
  if (alias_ == NULL) alias_ = new ::gunir::compiler::StringMessage;
  return alias_;
}
inline ::gunir::compiler::StringMessage* RawTarget::release_alias() {
  clear_has_alias();
  ::gunir::compiler::StringMessage* temp = alias_;
  alias_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RawTargetList

// repeated .gunir.compiler.RawTarget target_list = 1;
inline int RawTargetList::target_list_size() const {
  return target_list_.size();
}
inline void RawTargetList::clear_target_list() {
  target_list_.Clear();
}
inline const ::gunir::compiler::RawTarget& RawTargetList::target_list(int index) const {
  return target_list_.Get(index);
}
inline ::gunir::compiler::RawTarget* RawTargetList::mutable_target_list(int index) {
  return target_list_.Mutable(index);
}
inline ::gunir::compiler::RawTarget* RawTargetList::add_target_list() {
  return target_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTarget >&
RawTargetList::target_list() const {
  return target_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTarget >*
RawTargetList::mutable_target_list() {
  return &target_list_;
}

// required bool target_is_star = 2;
inline bool RawTargetList::has_target_is_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawTargetList::set_has_target_is_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawTargetList::clear_has_target_is_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawTargetList::clear_target_is_star() {
  target_is_star_ = false;
  clear_has_target_is_star();
}
inline bool RawTargetList::target_is_star() const {
  return target_is_star_;
}
inline void RawTargetList::set_target_is_star(bool value) {
  set_has_target_is_star();
  target_is_star_ = value;
}

// -------------------------------------------------------------------

// RawTable

// optional .gunir.compiler.StringMessage table_name = 1;
inline bool RawTable::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawTable::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawTable::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawTable::clear_table_name() {
  if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_name();
}
inline const ::gunir::compiler::StringMessage& RawTable::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::gunir::compiler::StringMessage* RawTable::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::gunir::compiler::StringMessage;
  return table_name_;
}
inline ::gunir::compiler::StringMessage* RawTable::release_table_name() {
  clear_has_table_name();
  ::gunir::compiler::StringMessage* temp = table_name_;
  table_name_ = NULL;
  return temp;
}

// optional .gunir.compiler.SelectStmt select_stmt = 2;
inline bool RawTable::has_select_stmt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawTable::set_has_select_stmt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawTable::clear_has_select_stmt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawTable::clear_select_stmt() {
  if (select_stmt_ != NULL) select_stmt_->::gunir::compiler::SelectStmt::Clear();
  clear_has_select_stmt();
}
inline const ::gunir::compiler::SelectStmt& RawTable::select_stmt() const {
  return select_stmt_ != NULL ? *select_stmt_ : *default_instance_->select_stmt_;
}
inline ::gunir::compiler::SelectStmt* RawTable::mutable_select_stmt() {
  set_has_select_stmt();
  if (select_stmt_ == NULL) select_stmt_ = new ::gunir::compiler::SelectStmt;
  return select_stmt_;
}
inline ::gunir::compiler::SelectStmt* RawTable::release_select_stmt() {
  clear_has_select_stmt();
  ::gunir::compiler::SelectStmt* temp = select_stmt_;
  select_stmt_ = NULL;
  return temp;
}

// optional .gunir.compiler.StringMessage alias = 9;
inline bool RawTable::has_alias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RawTable::set_has_alias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RawTable::clear_has_alias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RawTable::clear_alias() {
  if (alias_ != NULL) alias_->::gunir::compiler::StringMessage::Clear();
  clear_has_alias();
}
inline const ::gunir::compiler::StringMessage& RawTable::alias() const {
  return alias_ != NULL ? *alias_ : *default_instance_->alias_;
}
inline ::gunir::compiler::StringMessage* RawTable::mutable_alias() {
  set_has_alias();
  if (alias_ == NULL) alias_ = new ::gunir::compiler::StringMessage;
  return alias_;
}
inline ::gunir::compiler::StringMessage* RawTable::release_alias() {
  clear_has_alias();
  ::gunir::compiler::StringMessage* temp = alias_;
  alias_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RawTableList

// repeated .gunir.compiler.RawTable table_list = 1;
inline int RawTableList::table_list_size() const {
  return table_list_.size();
}
inline void RawTableList::clear_table_list() {
  table_list_.Clear();
}
inline const ::gunir::compiler::RawTable& RawTableList::table_list(int index) const {
  return table_list_.Get(index);
}
inline ::gunir::compiler::RawTable* RawTableList::mutable_table_list(int index) {
  return table_list_.Mutable(index);
}
inline ::gunir::compiler::RawTable* RawTableList::add_table_list() {
  return table_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTable >&
RawTableList::table_list() const {
  return table_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::gunir::compiler::RawTable >*
RawTableList::mutable_table_list() {
  return &table_list_;
}

// -------------------------------------------------------------------

// SelectStmt

// required .gunir.compiler.RawTargetList target_list = 1;
inline bool SelectStmt::has_target_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectStmt::set_has_target_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectStmt::clear_has_target_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectStmt::clear_target_list() {
  if (target_list_ != NULL) target_list_->::gunir::compiler::RawTargetList::Clear();
  clear_has_target_list();
}
inline const ::gunir::compiler::RawTargetList& SelectStmt::target_list() const {
  return target_list_ != NULL ? *target_list_ : *default_instance_->target_list_;
}
inline ::gunir::compiler::RawTargetList* SelectStmt::mutable_target_list() {
  set_has_target_list();
  if (target_list_ == NULL) target_list_ = new ::gunir::compiler::RawTargetList;
  return target_list_;
}
inline ::gunir::compiler::RawTargetList* SelectStmt::release_target_list() {
  clear_has_target_list();
  ::gunir::compiler::RawTargetList* temp = target_list_;
  target_list_ = NULL;
  return temp;
}

// required .gunir.compiler.RawTableList from_list = 2;
inline bool SelectStmt::has_from_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectStmt::set_has_from_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectStmt::clear_has_from_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectStmt::clear_from_list() {
  if (from_list_ != NULL) from_list_->::gunir::compiler::RawTableList::Clear();
  clear_has_from_list();
}
inline const ::gunir::compiler::RawTableList& SelectStmt::from_list() const {
  return from_list_ != NULL ? *from_list_ : *default_instance_->from_list_;
}
inline ::gunir::compiler::RawTableList* SelectStmt::mutable_from_list() {
  set_has_from_list();
  if (from_list_ == NULL) from_list_ = new ::gunir::compiler::RawTableList;
  return from_list_;
}
inline ::gunir::compiler::RawTableList* SelectStmt::release_from_list() {
  clear_has_from_list();
  ::gunir::compiler::RawTableList* temp = from_list_;
  from_list_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawExpression where_clause = 3;
inline bool SelectStmt::has_where_clause() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectStmt::set_has_where_clause() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectStmt::clear_has_where_clause() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectStmt::clear_where_clause() {
  if (where_clause_ != NULL) where_clause_->::gunir::compiler::RawExpression::Clear();
  clear_has_where_clause();
}
inline const ::gunir::compiler::RawExpression& SelectStmt::where_clause() const {
  return where_clause_ != NULL ? *where_clause_ : *default_instance_->where_clause_;
}
inline ::gunir::compiler::RawExpression* SelectStmt::mutable_where_clause() {
  set_has_where_clause();
  if (where_clause_ == NULL) where_clause_ = new ::gunir::compiler::RawExpression;
  return where_clause_;
}
inline ::gunir::compiler::RawExpression* SelectStmt::release_where_clause() {
  clear_has_where_clause();
  ::gunir::compiler::RawExpression* temp = where_clause_;
  where_clause_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawJoin join = 4;
inline bool SelectStmt::has_join() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SelectStmt::set_has_join() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SelectStmt::clear_has_join() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SelectStmt::clear_join() {
  if (join_ != NULL) join_->::gunir::compiler::RawJoin::Clear();
  clear_has_join();
}
inline const ::gunir::compiler::RawJoin& SelectStmt::join() const {
  return join_ != NULL ? *join_ : *default_instance_->join_;
}
inline ::gunir::compiler::RawJoin* SelectStmt::mutable_join() {
  set_has_join();
  if (join_ == NULL) join_ = new ::gunir::compiler::RawJoin;
  return join_;
}
inline ::gunir::compiler::RawJoin* SelectStmt::release_join() {
  clear_has_join();
  ::gunir::compiler::RawJoin* temp = join_;
  join_ = NULL;
  return temp;
}

// optional .gunir.compiler.ColumnPathList groupby = 5;
inline bool SelectStmt::has_groupby() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SelectStmt::set_has_groupby() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SelectStmt::clear_has_groupby() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SelectStmt::clear_groupby() {
  if (groupby_ != NULL) groupby_->::gunir::compiler::ColumnPathList::Clear();
  clear_has_groupby();
}
inline const ::gunir::compiler::ColumnPathList& SelectStmt::groupby() const {
  return groupby_ != NULL ? *groupby_ : *default_instance_->groupby_;
}
inline ::gunir::compiler::ColumnPathList* SelectStmt::mutable_groupby() {
  set_has_groupby();
  if (groupby_ == NULL) groupby_ = new ::gunir::compiler::ColumnPathList;
  return groupby_;
}
inline ::gunir::compiler::ColumnPathList* SelectStmt::release_groupby() {
  clear_has_groupby();
  ::gunir::compiler::ColumnPathList* temp = groupby_;
  groupby_ = NULL;
  return temp;
}

// optional .gunir.compiler.RawExpression having = 6;
inline bool SelectStmt::has_having() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SelectStmt::set_has_having() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SelectStmt::clear_has_having() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SelectStmt::clear_having() {
  if (having_ != NULL) having_->::gunir::compiler::RawExpression::Clear();
  clear_has_having();
}
inline const ::gunir::compiler::RawExpression& SelectStmt::having() const {
  return having_ != NULL ? *having_ : *default_instance_->having_;
}
inline ::gunir::compiler::RawExpression* SelectStmt::mutable_having() {
  set_has_having();
  if (having_ == NULL) having_ = new ::gunir::compiler::RawExpression;
  return having_;
}
inline ::gunir::compiler::RawExpression* SelectStmt::release_having() {
  clear_has_having();
  ::gunir::compiler::RawExpression* temp = having_;
  having_ = NULL;
  return temp;
}

// optional .gunir.compiler.OrderColumnPathList orderby = 7;
inline bool SelectStmt::has_orderby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SelectStmt::set_has_orderby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SelectStmt::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SelectStmt::clear_orderby() {
  if (orderby_ != NULL) orderby_->::gunir::compiler::OrderColumnPathList::Clear();
  clear_has_orderby();
}
inline const ::gunir::compiler::OrderColumnPathList& SelectStmt::orderby() const {
  return orderby_ != NULL ? *orderby_ : *default_instance_->orderby_;
}
inline ::gunir::compiler::OrderColumnPathList* SelectStmt::mutable_orderby() {
  set_has_orderby();
  if (orderby_ == NULL) orderby_ = new ::gunir::compiler::OrderColumnPathList;
  return orderby_;
}
inline ::gunir::compiler::OrderColumnPathList* SelectStmt::release_orderby() {
  clear_has_orderby();
  ::gunir::compiler::OrderColumnPathList* temp = orderby_;
  orderby_ = NULL;
  return temp;
}

// optional .gunir.compiler.Limit limit = 8;
inline bool SelectStmt::has_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SelectStmt::set_has_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SelectStmt::clear_has_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SelectStmt::clear_limit() {
  if (limit_ != NULL) limit_->::gunir::compiler::Limit::Clear();
  clear_has_limit();
}
inline const ::gunir::compiler::Limit& SelectStmt::limit() const {
  return limit_ != NULL ? *limit_ : *default_instance_->limit_;
}
inline ::gunir::compiler::Limit* SelectStmt::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) limit_ = new ::gunir::compiler::Limit;
  return limit_;
}
inline ::gunir::compiler::Limit* SelectStmt::release_limit() {
  clear_has_limit();
  ::gunir::compiler::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CreateTableStmt

// required .gunir.compiler.StringMessage table_name = 1;
inline bool CreateTableStmt::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateTableStmt::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateTableStmt::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateTableStmt::clear_table_name() {
  if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_name();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::gunir::compiler::StringMessage;
  return table_name_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_table_name() {
  clear_has_table_name();
  ::gunir::compiler::StringMessage* temp = table_name_;
  table_name_ = NULL;
  return temp;
}

// required .gunir.compiler.StringMessage input_path = 2;
inline bool CreateTableStmt::has_input_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateTableStmt::set_has_input_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateTableStmt::clear_has_input_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateTableStmt::clear_input_path() {
  if (input_path_ != NULL) input_path_->::gunir::compiler::StringMessage::Clear();
  clear_has_input_path();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::input_path() const {
  return input_path_ != NULL ? *input_path_ : *default_instance_->input_path_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_input_path() {
  set_has_input_path();
  if (input_path_ == NULL) input_path_ = new ::gunir::compiler::StringMessage;
  return input_path_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_input_path() {
  clear_has_input_path();
  ::gunir::compiler::StringMessage* temp = input_path_;
  input_path_ = NULL;
  return temp;
}

// required .gunir.compiler.StringMessage table_schema = 3;
inline bool CreateTableStmt::has_table_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateTableStmt::set_has_table_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateTableStmt::clear_has_table_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateTableStmt::clear_table_schema() {
  if (table_schema_ != NULL) table_schema_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_schema();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::table_schema() const {
  return table_schema_ != NULL ? *table_schema_ : *default_instance_->table_schema_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_table_schema() {
  set_has_table_schema();
  if (table_schema_ == NULL) table_schema_ = new ::gunir::compiler::StringMessage;
  return table_schema_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_table_schema() {
  clear_has_table_schema();
  ::gunir::compiler::StringMessage* temp = table_schema_;
  table_schema_ = NULL;
  return temp;
}

// required .gunir.compiler.StringMessage message_name = 4;
inline bool CreateTableStmt::has_message_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateTableStmt::set_has_message_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateTableStmt::clear_has_message_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateTableStmt::clear_message_name() {
  if (message_name_ != NULL) message_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_message_name();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::message_name() const {
  return message_name_ != NULL ? *message_name_ : *default_instance_->message_name_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_message_name() {
  set_has_message_name();
  if (message_name_ == NULL) message_name_ = new ::gunir::compiler::StringMessage;
  return message_name_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_message_name() {
  clear_has_message_name();
  ::gunir::compiler::StringMessage* temp = message_name_;
  message_name_ = NULL;
  return temp;
}

// optional .gunir.compiler.StringMessage charset_encoding = 5;
inline bool CreateTableStmt::has_charset_encoding() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateTableStmt::set_has_charset_encoding() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateTableStmt::clear_has_charset_encoding() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateTableStmt::clear_charset_encoding() {
  if (charset_encoding_ != NULL) charset_encoding_->::gunir::compiler::StringMessage::Clear();
  clear_has_charset_encoding();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::charset_encoding() const {
  return charset_encoding_ != NULL ? *charset_encoding_ : *default_instance_->charset_encoding_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_charset_encoding() {
  set_has_charset_encoding();
  if (charset_encoding_ == NULL) charset_encoding_ = new ::gunir::compiler::StringMessage;
  return charset_encoding_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_charset_encoding() {
  clear_has_charset_encoding();
  ::gunir::compiler::StringMessage* temp = charset_encoding_;
  charset_encoding_ = NULL;
  return temp;
}

// optional .gunir.compiler.StringMessage table_type = 6;
inline bool CreateTableStmt::has_table_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateTableStmt::set_has_table_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateTableStmt::clear_has_table_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateTableStmt::clear_table_type() {
  if (table_type_ != NULL) table_type_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_type();
}
inline const ::gunir::compiler::StringMessage& CreateTableStmt::table_type() const {
  return table_type_ != NULL ? *table_type_ : *default_instance_->table_type_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::mutable_table_type() {
  set_has_table_type();
  if (table_type_ == NULL) table_type_ = new ::gunir::compiler::StringMessage;
  return table_type_;
}
inline ::gunir::compiler::StringMessage* CreateTableStmt::release_table_type() {
  clear_has_table_type();
  ::gunir::compiler::StringMessage* temp = table_type_;
  table_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DefineTableStmt

// required .gunir.compiler.StringMessage table_name = 1;
inline bool DefineTableStmt::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DefineTableStmt::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DefineTableStmt::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DefineTableStmt::clear_table_name() {
  if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_name();
}
inline const ::gunir::compiler::StringMessage& DefineTableStmt::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::gunir::compiler::StringMessage* DefineTableStmt::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::gunir::compiler::StringMessage;
  return table_name_;
}
inline ::gunir::compiler::StringMessage* DefineTableStmt::release_table_name() {
  clear_has_table_name();
  ::gunir::compiler::StringMessage* temp = table_name_;
  table_name_ = NULL;
  return temp;
}

// required .gunir.compiler.StringMessage input_path = 2;
inline bool DefineTableStmt::has_input_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DefineTableStmt::set_has_input_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DefineTableStmt::clear_has_input_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DefineTableStmt::clear_input_path() {
  if (input_path_ != NULL) input_path_->::gunir::compiler::StringMessage::Clear();
  clear_has_input_path();
}
inline const ::gunir::compiler::StringMessage& DefineTableStmt::input_path() const {
  return input_path_ != NULL ? *input_path_ : *default_instance_->input_path_;
}
inline ::gunir::compiler::StringMessage* DefineTableStmt::mutable_input_path() {
  set_has_input_path();
  if (input_path_ == NULL) input_path_ = new ::gunir::compiler::StringMessage;
  return input_path_;
}
inline ::gunir::compiler::StringMessage* DefineTableStmt::release_input_path() {
  clear_has_input_path();
  ::gunir::compiler::StringMessage* temp = input_path_;
  input_path_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DropTableStmt

// required .gunir.compiler.StringMessage table_name = 1;
inline bool DropTableStmt::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropTableStmt::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropTableStmt::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropTableStmt::clear_table_name() {
  if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_name();
}
inline const ::gunir::compiler::StringMessage& DropTableStmt::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::gunir::compiler::StringMessage* DropTableStmt::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::gunir::compiler::StringMessage;
  return table_name_;
}
inline ::gunir::compiler::StringMessage* DropTableStmt::release_table_name() {
  clear_has_table_name();
  ::gunir::compiler::StringMessage* temp = table_name_;
  table_name_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ShowStmt

// optional .gunir.compiler.StringMessage table_name = 1;
inline bool ShowStmt::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShowStmt::set_has_table_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShowStmt::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShowStmt::clear_table_name() {
  if (table_name_ != NULL) table_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_table_name();
}
inline const ::gunir::compiler::StringMessage& ShowStmt::table_name() const {
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::gunir::compiler::StringMessage* ShowStmt::mutable_table_name() {
  set_has_table_name();
  if (table_name_ == NULL) table_name_ = new ::gunir::compiler::StringMessage;
  return table_name_;
}
inline ::gunir::compiler::StringMessage* ShowStmt::release_table_name() {
  clear_has_table_name();
  ::gunir::compiler::StringMessage* temp = table_name_;
  table_name_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// HelpStmt

// optional .gunir.compiler.StringMessage cmd_name = 1;
inline bool HelpStmt::has_cmd_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelpStmt::set_has_cmd_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelpStmt::clear_has_cmd_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelpStmt::clear_cmd_name() {
  if (cmd_name_ != NULL) cmd_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_cmd_name();
}
inline const ::gunir::compiler::StringMessage& HelpStmt::cmd_name() const {
  return cmd_name_ != NULL ? *cmd_name_ : *default_instance_->cmd_name_;
}
inline ::gunir::compiler::StringMessage* HelpStmt::mutable_cmd_name() {
  set_has_cmd_name();
  if (cmd_name_ == NULL) cmd_name_ = new ::gunir::compiler::StringMessage;
  return cmd_name_;
}
inline ::gunir::compiler::StringMessage* HelpStmt::release_cmd_name() {
  clear_has_cmd_name();
  ::gunir::compiler::StringMessage* temp = cmd_name_;
  cmd_name_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// QuitStmt

// optional .gunir.compiler.StringMessage cmd_name = 1;
inline bool QuitStmt::has_cmd_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuitStmt::set_has_cmd_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuitStmt::clear_has_cmd_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuitStmt::clear_cmd_name() {
  if (cmd_name_ != NULL) cmd_name_->::gunir::compiler::StringMessage::Clear();
  clear_has_cmd_name();
}
inline const ::gunir::compiler::StringMessage& QuitStmt::cmd_name() const {
  return cmd_name_ != NULL ? *cmd_name_ : *default_instance_->cmd_name_;
}
inline ::gunir::compiler::StringMessage* QuitStmt::mutable_cmd_name() {
  set_has_cmd_name();
  if (cmd_name_ == NULL) cmd_name_ = new ::gunir::compiler::StringMessage;
  return cmd_name_;
}
inline ::gunir::compiler::StringMessage* QuitStmt::release_cmd_name() {
  clear_has_cmd_name();
  ::gunir::compiler::StringMessage* temp = cmd_name_;
  cmd_name_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// HistoryStmt

// optional int32 start = 1;
inline bool HistoryStmt::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryStmt::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryStmt::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryStmt::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 HistoryStmt::start() const {
  return start_;
}
inline void HistoryStmt::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// optional int32 size = 2;
inline bool HistoryStmt::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryStmt::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryStmt::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryStmt::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 HistoryStmt::size() const {
  return size_;
}
inline void HistoryStmt::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// QueryStmt

// optional .gunir.compiler.SelectStmt select = 1;
inline bool QueryStmt::has_select() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryStmt::set_has_select() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryStmt::clear_has_select() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryStmt::clear_select() {
  if (select_ != NULL) select_->::gunir::compiler::SelectStmt::Clear();
  clear_has_select();
}
inline const ::gunir::compiler::SelectStmt& QueryStmt::select() const {
  return select_ != NULL ? *select_ : *default_instance_->select_;
}
inline ::gunir::compiler::SelectStmt* QueryStmt::mutable_select() {
  set_has_select();
  if (select_ == NULL) select_ = new ::gunir::compiler::SelectStmt;
  return select_;
}
inline ::gunir::compiler::SelectStmt* QueryStmt::release_select() {
  clear_has_select();
  ::gunir::compiler::SelectStmt* temp = select_;
  select_ = NULL;
  return temp;
}

// optional .gunir.compiler.CreateTableStmt create = 2;
inline bool QueryStmt::has_create() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryStmt::set_has_create() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryStmt::clear_has_create() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryStmt::clear_create() {
  if (create_ != NULL) create_->::gunir::compiler::CreateTableStmt::Clear();
  clear_has_create();
}
inline const ::gunir::compiler::CreateTableStmt& QueryStmt::create() const {
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
inline ::gunir::compiler::CreateTableStmt* QueryStmt::mutable_create() {
  set_has_create();
  if (create_ == NULL) create_ = new ::gunir::compiler::CreateTableStmt;
  return create_;
}
inline ::gunir::compiler::CreateTableStmt* QueryStmt::release_create() {
  clear_has_create();
  ::gunir::compiler::CreateTableStmt* temp = create_;
  create_ = NULL;
  return temp;
}

// optional .gunir.compiler.DropTableStmt drop = 3;
inline bool QueryStmt::has_drop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryStmt::set_has_drop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryStmt::clear_has_drop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryStmt::clear_drop() {
  if (drop_ != NULL) drop_->::gunir::compiler::DropTableStmt::Clear();
  clear_has_drop();
}
inline const ::gunir::compiler::DropTableStmt& QueryStmt::drop() const {
  return drop_ != NULL ? *drop_ : *default_instance_->drop_;
}
inline ::gunir::compiler::DropTableStmt* QueryStmt::mutable_drop() {
  set_has_drop();
  if (drop_ == NULL) drop_ = new ::gunir::compiler::DropTableStmt;
  return drop_;
}
inline ::gunir::compiler::DropTableStmt* QueryStmt::release_drop() {
  clear_has_drop();
  ::gunir::compiler::DropTableStmt* temp = drop_;
  drop_ = NULL;
  return temp;
}

// optional .gunir.compiler.HelpStmt help = 4;
inline bool QueryStmt::has_help() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryStmt::set_has_help() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryStmt::clear_has_help() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryStmt::clear_help() {
  if (help_ != NULL) help_->::gunir::compiler::HelpStmt::Clear();
  clear_has_help();
}
inline const ::gunir::compiler::HelpStmt& QueryStmt::help() const {
  return help_ != NULL ? *help_ : *default_instance_->help_;
}
inline ::gunir::compiler::HelpStmt* QueryStmt::mutable_help() {
  set_has_help();
  if (help_ == NULL) help_ = new ::gunir::compiler::HelpStmt;
  return help_;
}
inline ::gunir::compiler::HelpStmt* QueryStmt::release_help() {
  clear_has_help();
  ::gunir::compiler::HelpStmt* temp = help_;
  help_ = NULL;
  return temp;
}

// optional .gunir.compiler.ShowStmt show = 5;
inline bool QueryStmt::has_show() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryStmt::set_has_show() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryStmt::clear_has_show() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryStmt::clear_show() {
  if (show_ != NULL) show_->::gunir::compiler::ShowStmt::Clear();
  clear_has_show();
}
inline const ::gunir::compiler::ShowStmt& QueryStmt::show() const {
  return show_ != NULL ? *show_ : *default_instance_->show_;
}
inline ::gunir::compiler::ShowStmt* QueryStmt::mutable_show() {
  set_has_show();
  if (show_ == NULL) show_ = new ::gunir::compiler::ShowStmt;
  return show_;
}
inline ::gunir::compiler::ShowStmt* QueryStmt::release_show() {
  clear_has_show();
  ::gunir::compiler::ShowStmt* temp = show_;
  show_ = NULL;
  return temp;
}

// optional .gunir.compiler.HistoryStmt history = 6;
inline bool QueryStmt::has_history() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryStmt::set_has_history() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryStmt::clear_has_history() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryStmt::clear_history() {
  if (history_ != NULL) history_->::gunir::compiler::HistoryStmt::Clear();
  clear_has_history();
}
inline const ::gunir::compiler::HistoryStmt& QueryStmt::history() const {
  return history_ != NULL ? *history_ : *default_instance_->history_;
}
inline ::gunir::compiler::HistoryStmt* QueryStmt::mutable_history() {
  set_has_history();
  if (history_ == NULL) history_ = new ::gunir::compiler::HistoryStmt;
  return history_;
}
inline ::gunir::compiler::HistoryStmt* QueryStmt::release_history() {
  clear_has_history();
  ::gunir::compiler::HistoryStmt* temp = history_;
  history_ = NULL;
  return temp;
}

// optional .gunir.compiler.QuitStmt quit = 7;
inline bool QueryStmt::has_quit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QueryStmt::set_has_quit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QueryStmt::clear_has_quit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QueryStmt::clear_quit() {
  if (quit_ != NULL) quit_->::gunir::compiler::QuitStmt::Clear();
  clear_has_quit();
}
inline const ::gunir::compiler::QuitStmt& QueryStmt::quit() const {
  return quit_ != NULL ? *quit_ : *default_instance_->quit_;
}
inline ::gunir::compiler::QuitStmt* QueryStmt::mutable_quit() {
  set_has_quit();
  if (quit_ == NULL) quit_ = new ::gunir::compiler::QuitStmt;
  return quit_;
}
inline ::gunir::compiler::QuitStmt* QueryStmt::release_quit() {
  clear_has_quit();
  ::gunir::compiler::QuitStmt* temp = quit_;
  quit_ = NULL;
  return temp;
}

// optional .gunir.compiler.DefineTableStmt define = 8;
inline bool QueryStmt::has_define() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QueryStmt::set_has_define() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QueryStmt::clear_has_define() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QueryStmt::clear_define() {
  if (define_ != NULL) define_->::gunir::compiler::DefineTableStmt::Clear();
  clear_has_define();
}
inline const ::gunir::compiler::DefineTableStmt& QueryStmt::define() const {
  return define_ != NULL ? *define_ : *default_instance_->define_;
}
inline ::gunir::compiler::DefineTableStmt* QueryStmt::mutable_define() {
  set_has_define();
  if (define_ == NULL) define_ = new ::gunir::compiler::DefineTableStmt;
  return define_;
}
inline ::gunir::compiler::DefineTableStmt* QueryStmt::release_define() {
  clear_has_define();
  ::gunir::compiler::DefineTableStmt* temp = define_;
  define_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace compiler
}  // namespace gunir

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< gunir::compiler::OrderType>() {
  return gunir::compiler::OrderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< gunir::compiler::Operators>() {
  return gunir::compiler::Operators_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< gunir::compiler::JoinOperator>() {
  return gunir::compiler::JoinOperator_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_select_5fstmt_2eproto__INCLUDED
